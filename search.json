[{"title":"网易云音乐ncm文件加密格式解析","url":"//technology/csharp/neteasecloudmusic/","content":"本文章内容不得用于商业用途，仅做学习交流。如作他用所承受的法律责任一概与作者无关。\nNCM格式是网易云音乐独有的文件格式，且无法脱离网易云音乐程序播放。所以解码的逻辑一定就在网易云音乐的程序里面。可以从各个平台的客户端入手，寻找一下解密的痕迹。\n\n 开局一张图，剩下全靠编(码) —— NCM文件结构组成\n按照文件结构，采用 Chain of Responsibility 模式构建解析过程。其中最核心的几个技术点：\n\nRC4算法\nMeta信息解析\nMeta后缀是flac但实际格式有可能是mp3\n\nRC4、AES算法内容可以参考这本书 应用密码学：协议、算法与C源程序（原书第2版） 。\n/*\n * RC4算法\n */\npublic class RC4\n&#123;\n    private readonly byte[] _box = new byte[256];\n\n    public void KSA(byte[] key)\n    &#123;\n        var len = key.Length;\n        for (var i = 0; i &lt; 256; i++) _box[i] = (byte)i;\n\n        for (int i = 0, j = 0; i &lt; 256; i++)\n        &#123;\n            j = (j + _box[i] + key[i % len]) &amp; 0xff;\n            (_box[i], _box[j]) = (_box[j], _box[i]);\n        &#125;\n    &#125;\n\n    public void PRGA(byte[] data, int length)\n    &#123;\n        for (var k = 0; k &lt; length; k++)\n        &#123;\n            var i = (k + 1) &amp; 0xff;\n            var j = (_box[i] + i) &amp; 0xff;\n            data[k] ^= _box[(_box[i] + _box[j]) &amp; 0xff];\n        &#125;\n    &#125;\n&#125;\n\n\n格式不匹配问题，是在用TagLib写入Meta数据的时候抛异常发现的。需要读取 File Signatures 来判断。\n//兼容file signatures是mp3但后缀是flac的歌曲\nif (BitConverter.ToString(ncmObject.MusicDataArray.Slice(0, 3).ToArray()).Equals(\"49-44-33\"))\n    ncmObject.NeteaseCopyrightData.Format = \"mp3\";\n\n\n其他地方没什么难度。话说回来，.Net跨平台任重道远。Mac上面跑只需要500MB+，Windows上面能用掉3G内存。\n完整的代码在 这里 ，支持 Windows &amp; MacOS。\n编译成功后使用 -p,–path 参数传入目录即可。\n\n\n使用 Sony NW-ZX300A 实测可以正常显示专辑封面，HiRes标志也正常显示，我又可以做回 Walkman 了\n\n","categories":["技术",".Net"],"tags":["C#"]},{"title":"字符","url":"//technology/java/characters/","content":"字符大多数情况下，若使用单字符值，则采用 char 类型。例如：\nchar ch = 'a';\n// Unicode for uppercase Greek omega character\nchar uniChar = '\\u03A9';\n// an array of chars\nchar[] charAarray = &#123;'a', 'b', 'c', 'd', 'e'&#125;;\n然而，有时你需要将字符作为对象使用——例如作为方法参数时，该参数要求传入对象。Java编程语言为此提供了一个包装类，它将字符”包装”成Character对象。Character类型的对象包含一个字段，其类型为字符。该Character类还提供了一系列有用的类方法（即静态方法）来操作字符。\n\n\n你可以使用字符构造函数创建一个字符对象：\nCharacter ch = new Character('a');\n在某些情况下，Java编译器也会为你创建Character对象。例如，当你将原始char类型传递给期望接收对象的方法时，编译器会自动将char转换为Character。此功能称为autoboxing——若转换方向相反，则称为unboxing。有关自动装箱和拆箱的更多信息，请参阅”自动装箱与拆箱”章节。\n\n注意：Character类是不可变的，因此一旦创建，Character对象就无法被修改。下表列出了 Character 类中一些最实用的方法，但并非详尽无遗。如需查看该类所有方法的完整列表（超过50个），请参阅 Character API 规范。\n\n\nboolean isLetter(char ch) 和 boolean isDigit(char ch)：分别判断指定的字符值是否为字母或数字。\nboolean isWhitespace(char ch)： 判断指定的字符值是否为空白字符。\nboolean isUpperCase(char ch) 和 boolean isLowerCase(char ch)：分别判断指定字符值是大写还是小写。\nchar toUpperCase(char ch) 和 char toLowerCase(char ch)： 返回指定字符值的大写或小写形式。\ntoString(char ch)：返回一个String对象，表示指定的字符值——即一个单字符字符串。\n\n字符和码点Java平台自JDK 1.0.2起便支持Unicode标准。Java SE 15支持Unicode 13.0。char数据类型和Character类基于原始Unicode规范，该规范将字符定义为固定宽度的16位实体。此后Unicode标准已修订，允许存在需要超过16位表示的字符。合法码点的范围现为U+0000至U+10FFFF，称为Unicode标量值。\n字符值采用16位编码，因此可表示 0x0000 至 0xFFFF 之间的数值。这组字符有时被称为 Basic Multilingual Plane（BMP）。代码点大于 0xFFFF（记为U+FFFF）的字符称为 supplementary characters。\n因此，一个char值代表 Basic Multilingual Plane（BMP）中的码点。一个int值则代表所有Unicode码点，包括补充码点。除非另有说明，否则对补充字符和代理字符值的行为如下：\n\n仅接受 char 值的方法无法支持补充字符。它们将来自代理范围的char值视为未定义字符。\n接受 int 值的方法支持所有Unicode字符，包括补充字符。\n\n有关更多信息，请参阅 Character 类的文档。\n转义序列以反斜杠 \\ 开头的字符是转义序列，对编译器具有特殊含义。下表列出了 Java 转义序列：\n\n\n\n转义序列\n含义\n\n\n\n\\t\n在此处插入一个制表符(tab)。\n\n\n\\b\n在此处文本中插入一个退格符(backspace)。\n\n\n\\n\n在此处文本中插入换行符(line feed)。\n\n\n\\r\n在此处文本中插入回车符(carriage return)。\n\n\n\\f\n在此处文本中插入换页符(form feed)。\n\n\n\\&#39;\n在此处插入单引号字符(&#39;)。\n\n\n\\&quot;\n在此处插入双引号字符(&quot;)。\n\n\n\\\\\\\n在此处插入反斜杠字符(\\)。\n\n\n当打印语句中遇到转义序列时，编译器会进行相应处理。例如，若要在引号内嵌套引号，必须在内部引号处使用转义序列”,。要打印句子\nShe said \"Hello!\" to me.\n必须使用如下代码：\nIO.println(\"She said \\\"Hello!\\\" to me.\");","categories":["技术","Java"],"tags":["Java Programming Language"]},{"title":"Boxing and Unboxing in Java","url":"//technology/java/boxingandunboxing/","content":"装箱(Boxing) 和 拆箱(Unboxing)Autoboxing 是指Java编译器在基本类型与其对应的对象包装类之间进行的自动转换。例如，将int转换为Integer，将double转换为Double，等等。如果转换方向相反，则称为Unboxing。\n以下是最简单的自动装箱示例：\nCharacter ch = 'a';\n本节其余示例均使用泛型。若您尚未熟悉泛型的语法，请参阅泛型章节。\n\n考虑以下代码：\nList&lt;Integer> ints = new ArrayList&lt;>();\nfor (int i = 1; i &lt; 50; i+=2) &#123;\n    ints.add(i); \n&#125;\n尽管你向 ints 中添加的是 int 值（原始类型）而非 Integer 对象，代码仍能编译通过。由于 ints 是 Integer 对象的列表而非 int 值的列表，你可能会疑惑为何 Java 编译器未在编译时报错。编译器之所以不报错，是因为它会将i转换为Integer对象，再将该对象加入ints列表。因此编译器会在运行时将原代码转换为以下形式：\nList&lt;Integer> ints = new ArrayList&lt;>();\nfor (int i = 1; i &lt; 50; i+=2) &#123;\n    ints.add(Integer.valueOf(i)); \n&#125;\n将基本类型值（例如整型）转换为对应包装类Integer的对象称为自动装箱。当基本类型值满足以下条件时，Java编译器会应用自动装箱：\n\n作为参数传递给一个方法，该方法期望接收对应包装类的对象。\n赋值给一个对应包装类的变量。\n\n考虑以下方法：\npublic static int sumEven(List&lt;Integer> ints) &#123;\n    int sum = 0;\n    for (Integer i: ints) &#123;\n        if (i % 2 == 0) &#123;\n            sum+=i;\n        &#125;\n    &#125;\n    return sum;\n&#125;\n由于取余运算符（%）和单目加运算符（+&#x3D;）不适用于Integer bjects，您可能会疑惑Java编译器为何能无误编译该方法。编译器之所以不报错，是因为它会在运行时调用intValue()方法将Integer转换为int类型：\n public static int sumEven(List&lt;Integer> ints) &#123;\n        int sum = 0;\n        for (Integer i : ints) &#123;\n            if (i.intValue() % 2 == 0) &#123;\n                sum += i.intValue();\n            &#125;\n        &#125;\n        return sum;\n&#125;\n将包装类型Integer的对象转换为其对应的原始类型（int）值称为unboxing(拆箱)。当包装类的对象满足以下条件时，Java编译器会执行拆箱操作：\n\n作为参数传递给一个方法，该方法期望接收对应基本数据类型的值。\n赋值给对应基本类型的变量。\n\nUnboxing 示例展示了其工作原理：\npublic class Unboxing &#123;\n    public static void main(String[] args) &#123;\n        Integer i = Integer.valueOf(-8);\n\n        // 1. Unboxing through method invocation\n        int absVal = absoluteValue(i);\n        IO.println(\"absolute value of \" + i + \" = \" + absVal);\n\n        List&lt;Double> doubles = new ArrayList&lt;>();\n        doubles.add(3.1416); // Π is autoboxed through method invocation\n\n        // 2. Unboxing through assignment\n        double pi = doubles.get(0);\n        IO.println(\"pi = \" + pi);\n    &#125;\n\n    public static int absoluteValue(int i)&#123;\n        return i &lt; 0 ? -i : i;\n    &#125;\n&#125;\n程序的输出如下：\nabsolute value of -8 = 8\npi = 3.1416\n\n自动装箱和拆箱功能使开发人员能够编写更简洁的代码，从而更易于阅读。下表列出了基本类型及其对应的包装类，这些包装类被Java编译器用于自动装箱和拆箱操作：\n\n\n\n基本类型\n包装类\n\n\n\nboolean\nBoolean\n\n\nbyte\nByte\n\n\nchar\nCharacter\n\n\nfloat\nFloat\n\n\nint\nInteger\n\n\nlong\nLong\n\n\nshort\nShort\n\n\ndouble\nDouble\n\n\n","categories":["技术","Java"],"tags":["Java Programming Language"]},{"title":"数组","url":"//technology/java/array/","content":"数组数组是一种容器对象，用于存储固定数量的单一类型值。数组的长度在创建时确定，创建后长度固定不变。你在”Hello World!”应用程序的主方法中已经见过数组的示例。本节将更详细地讨论数组。\n\n数组中的每个项称为元素，通过其数字索引访问每个元素。如前图所示，编号从0开始。例如，第6个元素的索引为5。以下程序 ArrayDemo 创建一个整型数组，向数组中赋值，并将每个值打印到标准输出。\npublic class ArrayDemo &#123;\n    public static void main(String[] args) &#123;\n        // declares an array of integers\n        int[] anArray;\n\n        // allocates memory for 10 integers\n        anArray = new int[10];\n\n        // initialize the first element\n        anArray[0] = 100;\n\n        //initialize the second element\n        anArray[1] = 200;\n\n        // and so forth\n        anArray[2] = 300;\n        anArray[3] = 400;\n        anArray[4] = 500;\n        anArray[5] = 600;\n        anArray[6] = 700;\n        anArray[7] = 800;\n        anArray[8] = 900;\n        anArray[9] = 1000;\n        \n        IO.println(\"Element at index 0: \" + anArray[0]);\n        IO.println(\"Element at index 1: \" + anArray[1]);\n        IO.println(\"Element at index 2: \" + anArray[2]);\n        IO.println(\"Element at index 3: \" + anArray[3]);\n        IO.println(\"Element at index 4: \" + anArray[4]);\n        IO.println(\"Element at index 5: \" + anArray[5]);\n        IO.println(\"Element at index 6: \" + anArray[6]);\n        IO.println(\"Element at index 7: \" + anArray[7]);\n        IO.println(\"Element at index 8: \" + anArray[8]);\n        IO.println(\"Element at index 9: \" + anArray[9]);\n    &#125;\n&#125;\n这个程序的输出如下所示：\nElement at index 0: 100\nElement at index 1: 200\nElement at index 2: 300\nElement at index 3: 400\nElement at index 4: 500\nElement at index 5: 600\nElement at index 6: 700\nElement at index 7: 800\nElement at index 8: 900\nElement at index 9: 1000\n在实际编程场景中，您通常会使用支持的循环结构遍历数组中的每个元素，而非像前例那样逐行编写代码。不过该示例清晰地展示了数组语法。您将在控制流章节中学习各种循环结构（for、while 和 do-while）。\n声明变量以引用数组前面的程序通过以下代码声明了一个名为 anArray 的数组：\n// declares an array of integers\nint[] anArray;\n与其他类型变量的声明类似，数组声明包含两个组成部分：数组类型和数组名称。数组类型写为 type[]，其中 type 是包含元素的数据类型；方括号是特殊符号，表示该变量持有数组。数组的大小不属于其类型的一部分（因此方括号为空）。数组名称可自由命名，但须遵循”类”章节所述的命名规则与约定。与其他类型变量相同，声明本身不会实际创建数组，仅告知编译器该变量将存储指定类型的数组。同样地，你可以声明其他类型的数组：\nbyte[] anArrayOfBytes;\nshort[] anArrayOfShorts;\nlong[] anArrayOfLongs;\nfloat[] anArrayOfFloats;\ndouble[] anArrayOfDoubles;\nboolean[] anArrayOfBooleans;\nchar[] anArrayOfChars;\nString[] anArrayOfStrings;\n你也可以把括号放在数组名称之后：\n// this form is discouraged\nfloat anArrayOfFloats[];\n然而，惯例不鼓励这种形式；括号用于标识数组类型，应与类型标识符一同出现。\n创建、初始化和访问一个数组创建数组的一种方式是使用new操作符。ArrayDemo程序中的下一条语句分配了一个能容纳10个整数元素的数组，并将该数组赋值给变量anArray。\n// create an array of integers\nanArray = new int[10];\n如果缺少此语句，编译器将输出类似以下的错误信息，编译失败：\nArrayDemo.java:4: Variable anArray may not have been initialized.\n接下来几行代码为数组的每个元素赋值：\nanArray[0] = 100; // initialize the first element\nanArray[1] = 200; // initialize the second element\nanArray[2] = 300; // initialize the third element\n每个数组元素通过其数字索引(numerical index 为什么中文要叫下标？)进行访问：\nIO.println(\"Element at index 0: \" + anArray[0]);\nIO.println(\"Element at index 1: \" + anArray[1]);\nIO.println(\"Element at index 2: \" + anArray[2]);\n或者，你可以使用快捷语法来创建并初始化数组：\nint[] anArray = &#123;\n    100, 200, 300,\n    400, 500, 600,\n    700, 800, 900, 1000\n&#125;\n此处数组的长度由大括号内以逗号分隔的值的数量决定。\n创建多维数组由于数组可以存储任何引用，且数组本身就是一种引用，因此可以轻松创建数组的数组。数组的数组也称为多维数组。可通过使用两个或多个方括号组来声明它们，例如 String[][] names。因此，每个元素都必须通过对应数量的索引值来访问。\n在Java编程语言中，多维数组是指其元素本身也是数组的数组。这与C或Fortran中的数组不同——在这些语言中，二维数组是内存中连续的区域，可通过指针直接访问。Java中的数组虽也是内存中连续的区域，但由于二维数组本质上是引用数组，因此其本身并非连续的内存区域。由此产生的结果是，行长度可以变化，如下面的MultiDimArrayDemo程序所示：\npublic class MultiDimArrayDemo &#123;\n    public static void main(String[] args) &#123;\n        String[][] names = &#123;\n            &#123;\"Mr. \", \"Mrs. \", \"Ms. \"&#125;,\n            &#123;\"Smith\", \"Jones\"&#125;\n        &#125;;\n\n        // Mr.Smith\n        IO.println(names[0][0] + names[1][0]);\n        // Ms.Jones\n        IO.println(names[0][2] + names[1][1]);\n    &#125;\n&#125;\n这个程序的输出如下所示\nMr. Smith\nMs. Jones\n这些数组有时候被称为不规则数组，或者锯齿形数组。\n##使用数组的长度属性最后，您可以使用任何数组上定义的内置 length 属性来确定该数组的大小。以下代码将数组的大小打印到标准输出：\nIO.println(anArray.length);\n这对于嵌套数组尤其有用，其中每个数组的长度可能不同。您的代码不应假设所有这些数组长度相同，而应依赖此长度属性，如下面的代码所示：\nvoid displayBidimensionalArray(String[][] strings)&#123;\n    for (int arrayIndex = 0; arrayIndex &lt; strings.length; arrayIndex++) &#123;\n        for (int index = 0; index &lt; strings[arrayIndex].length; index++) &#123;\n            IO.print(strings[arrayIndex][index]+ \" \");\n        &#125;\n        IO.println();\n    &#125;\n&#125;\n你可以使用以下数组调用此方法。\nString[][] strings = &#123;\n    &#123;\"one\"&#125;,\n    &#123;\"Maria\", \"Jennifer\", \"Particia\"&#125;,\n    &#123;\"James\", \"Michael\"&#125;,\n    &#123;\"Washington\", \"London\", \"Paris\", \"Berlin\", \"Tokyo\"&#125;\n&#125;;\n\ndisplayBidimensionalArray(strings);\n代码的输出如下所示：\none \nMaria Jennifer Particia \nJames Michael \nWashington London Paris Berlin Tokyo \n\n数组的拷贝System类提供了一个arraycopy()方法，可用于高效地将数据从一个数组复制到另一个数组：\npublic static void arraycopy(Object src, int srcPos, \n                             Object dest, int destPos, int length)\n两个对象参数分别指定要复制的源数组和目标数组。三个整数参数分别指定源数组的起始位置、目标数组的起始位置以及要复制的数组元素数量。以下程序 ArrayCopyDemo 声明了一个字符串元素数组。它使用 System.arraycopy() 方法将数组中部分元素复制到第二个数组：\npublic class ArrayCopyDemo &#123;\n    public static void main(String[] args) &#123;\n        String[] copyFrom = &#123;\n            \"Affogato\", \"Americano\", \"Cappuccino\", \"Corretto\", \"Cortado\",\n            \"Doppio\", \"Espresso\", \"Frappucino\", \"Freddo\", \"Lungo\", \"Macchiato\",\n            \"Marocchino\", \"Ristretto\"&#125;;\n        String[] copyTo = new String[7];\n        System.arraycopy(copyFrom, 2, copyTo, 0, 7);\n\n        for (String coffee : copyTo) &#123;\n            IO.print(coffee + \" \");\n        &#125;\n        IO.println();\n    &#125;\n&#125;\n\n代码输出如下所示：\nCappuccino Corretto Cortado Doppio Espresso Frappucino Freddo\n\n数组的操作数组是编程中一种强大且实用的概念。Java SE 提供了执行数组相关常见操作的方法。例如，ArrayCopyDemo 示例使用 System 类的 arraycopy() 方法，而非手动遍历源数组的元素并将每个元素逐个放入目标数组。该操作在后台自动完成，开发者只需一行代码即可调用该方法。为方便起见，Java SE 在 Arrays 类中提供了多种方法来执行数组操作（如复制、排序和搜索数组等常见任务）。例如，前面的示例可修改为使用 Arrays 类的 Arrays 方法，具体可参见 ArrayCopyOfDemo 示例。其区别在于：使用 Arrays 方法时无需在调用前创建目标数组，因为该方法会直接返回目标数组：\npublic class ArrayCopyOfDemo &#123;\n    public static void main(String[] args) &#123;\n         String[] copyFrom = &#123;\n            \"Affogato\", \"Americano\", \"Cappuccino\", \"Corretto\", \"Cortado\",\n            \"Doppio\", \"Espresso\", \"Frappucino\", \"Freddo\", \"Lungo\", \"Macchiato\",\n            \"Marocchino\", \"Ristretto\"&#125;;\n        String[] copyTo = Arrays.copyOfRange(copyFrom, 2, 9);\n\n        for (String coffee : copyTo) &#123;\n            IO.print(coffee + \" \");\n        &#125;\n        IO.println();\n    &#125;\n&#125;\n如您所见，该程序的输出结果相同，不过所需代码行数更少。请注意，Arrays方法的第二个参数是待复制范围的起始索引（包含该索引），而第三个参数是待复制范围的结束索引（不包含该索引）。在此示例中，待复制的范围不包含索引为9的数组元素（该元素包含字符串 Lungo）。\n数组类方法提供的其他有用操作包括：\n\n\n在数组中搜索特定值以获取其所在的索引位置（the binarySearch() method）。\n比较两个数组以确定它们是否相等（equals()方法）。\n填充数组以在每个索引处放置特定值（fill()方法）。\n将数组按升序排序。这既可通过顺序方式使用 sort() 方法实现，也可通过 Java SE 8 引入的 parallelSort() 方法并行完成。在多处理器系统上，对大型数组进行并行排序的速度快于顺序排序。\n创建一个以数组作为源的流（使用 stream() 方法）。例如，以下语句以与前例相同的方式打印 copyTo 数组的内容：\n\n\nArrays.stream(copyTo).map(coffee -> coffee + \" \").forEach(IO::print);\n\n有关流的更多信息，请参阅聚合操作。\n\n将数组转换为字符串。toString()方法将数组的每个元素转换为字符串，用逗号分隔，然后用方括号包围。例如，以下语句将 copyTo 数组转换为字符串并打印出来：\n\n\nIO.println(Arrays.toString(copyTo));\n\n该语句的输出如下所示：\n\n[Cappuccino, Corretto, Cortado, Doppio, Espresso, Frappucino, Freddo]\n\n变量与数组的封装Java编程语言在其术语体系中同时使用”字段”和”变量”的概念。实例变量（非静态字段）是类每个实例专属的。类变量（静态字段）是通过static修饰符声明的字段；无论类被实例化多少次，类变量都仅存在一份副本。局部变量用于存储方法内部的临时状态。参数则是为方法提供额外信息的变量；局部变量和参数均始终被归类为”变量”（而非”字段”）。为字段或变量命名时，存在必须遵循的命名规则与约定。八种基本数据类型为：byte、short、int、long、float、double、boolean 和 char。java.lang.String 类表示字符串。编译器会为上述类型的字段分配合理的默认值；对于局部变量，则永远不会分配默认值。\n字面量是固定值在源代码中的表示形式。数组是一种容器对象，用于存储固定数量的单一类型值。数组的长度在创建时确定，创建后其长度固定不变。\n","categories":["技术","Java"],"tags":["Java Programming Language"]},{"title":"构造函数","url":"//technology/java/constructors/","content":"定义一个构造函数类包含构造函数，用于根据类蓝图创建对象。构造函数声明与方法声明类似——但它们使用类名且没有返回类型。例如，Bicycle 类有一个构造函数：\npublic Bicycle(int startCadence, int startSpeed, int startGear) &#123;\n        gear = startGear;\n        cadence = startCadence;\n        speed = startSpeed;\n&#125;\n\n要创建名为 myBike 的新 Bicycle 对象，需通过 new 运算符调用构造函数：\nBicycle myBike = new Bicycle(30, 0, 8);\n代码 new Bicycle(30, 0, 8) 在内存中为该对象分配空间并初始化其字段。尽管 Bicycle 类只有一个构造函数，但它也可以拥有其他构造函数，包括无参数构造函数：\npublic Bicycle() &#123;\n    gear = 1;\n    cadence = 10;\n    speed = 0;\n&#125;\n代码 Bicycle yourBike &#x3D; new Bicycle(); 调用无参构造函数创建名为 yourBike 的新 Bicycle 对象。这两个构造函数本可以声明在 Bicycle 类中，因为它们的参数列表不同。与方法类似，Java平台根据参数列表的数量和类型来区分构造函数。你不能为同一个类编写两个具有相同参数数量和类型的构造函数，因为编译器无法区分它们。这样做会导致编译时错误。\n您无需为类提供构造函数，但操作时需谨慎。编译器会为任何未定义构造函数的类自动生成无参默认构造函数。该默认构造函数将调用父类的无参构造函数。此时若父类未提供无参构造函数，编译器将报错，因此必须确认父类存在该构造函数。若类未显式指定父类，则其隐式父类为 Object 类，该类具备无参构造函数。\n您可主动调用父类构造函数。本课开篇的 MountainBike 类正是如此操作。此机制将在后续接口与继承章节中详述。\n您可在构造函数声明中使用访问修饰符，以控制其他类调用该构造函数的权限。\n","categories":["技术","Java"],"tags":["Java Programming Language"]},{"title":"单人自驾1.3万公里后，我明白了什么","url":"//life/selfdriving/","content":" 没有什么能够阻挡，你对自由的向往。许巍 —《蓝莲花》\n&nbsp;&nbsp;&nbsp;&nbsp;从2010年参加工作，到2023年眨眼14个年头了。23年中遇到难得的机会，可以不再为工作所累。接连考完PMP和ACP后，时间来到了8月。该做些什么，才能不辜负这难得的gap时光呢？我时常思考这个问题。要不出去看看吧，等结了婚有了娃，很难有这么长的时间了。从思考到决定，用了1个小时不到的时间。\n&nbsp;&nbsp;&nbsp;&nbsp;去哪儿？怎么去？和谁？时间足够的话，要不去远一点，就西藏吧。虽然有油车也有纯电，但Model Y空间很大，而且油价也不低，要不挑战一下开纯电去吧。前两个问题从出现到决定花了不到10分钟，最后一个问题，问了10个朋友，9个要还房贷，还有1个老婆不给钱。以前婚姻叫围城，现在似乎背着房贷也叫围城。摇不到人，我就自己去。\n\n\n\n写在最前面的攻略    \n318川藏南线行程地图\n\n\n\n109青藏线行程地图\n\n我的行程\n318国道：    \n\n上海-&gt;铜陵-&gt;武汉-&gt;宜昌-&gt;重庆-&gt;天全服务区(雅安市天全县)-&gt;康定\n康定-&gt;雅江-&gt;巴塘-&gt;如美(芒康)-&gt;左贡-&gt;巴宿-&gt;波密-&gt;林芝-&gt;拉萨\n拉萨-&gt;日喀则-&gt;珠峰大本营(定日县巴松村)\n\n\n\n\n\n109国道：\n\n拉萨-&gt;那曲-&gt;安多\n沱沱河(唐古拉山镇)-&gt;格尔木\n\n\n\n\n城市道路没有什么好说的，后勤配套齐全，唯一要说的就是天全服务区。这个服务区是318平原路段最后一个大型补给型服务区，户外装备、医疗装备、车辆装备一应俱全。建议每一个自驾的人都在这里休整，按照自己的需求补给。\n高原反应318行程的规划，按照低海拔住宿，高海拔路过的原则制定的。109行程的规划，全是按照保命的原则制定的。康定海拔2000米+，建议适当的跑跳，轻微运动，检测自己是否有高原反应，以及休整适应。如果在这里轻微运动就高反了，第一个建议是终止行程。第二个建议是在康定买上高压氧气瓶，或者氧气袋。高压氧气瓶318国道能充的地方不多，提前做好规划。氧气袋可以在医院、药店充，便宜，氧气质量还高。强烈不建议购买罐装氧气瓶。康定西出第一座山是折多山，海拔4200米。如果仍然有高原反应，强烈建议终止行程。每个人身体素质不一样，不要硬撑。高原地区的120急救不堵车还好，堵车的话一两个小时到也是正常的。 说到高反，我就准备了三样东西：红牛、可乐，布洛芬。如果到这里都没有发生高反，那可以继续行程了，下一个容易高反的是丁真故乡，世界高城理塘(海拔4000米)，在雅江-&gt;巴塘行程中间。相比较垭口那一点时间，很多人会在理塘吃午饭，打卡拍照留念，理塘还有毛娅大草原、长青春科尔寺等景点，停留时间比较长，极易发生高反。高反的发生都是滞后的，我是中午路过理塘玩耍的，开了六个小时车快到巴塘发生的高反，头疼、犯困。布洛芬、红牛、可乐三管齐下，最后在金沙江边上的一家温泉酒店住宿的。泡泡温泉，休整一天后高反症状消失。\n109国道平均海拔4500米，318还能看到树木、绿叶，109国道因为缺少这些，氧气含量极低，所以上海-拉萨的列车到了格尔木要换供氧车厢，身体素质不好的，不建议自驾。\n路况318国道四川境内基本都是铺装路面，非常好开。跨过金沙江，就是西藏了。西藏境内的路况，就不太一样了，路况急转直下，会有石头+泥土的烂路。再加上常年修路，会遇到道路管制，提前和交警沟通好，做好规划。西藏的交警态度非常好，感觉是交警届的天花板了。唯一感觉危险的路段，就是过了怒江大桥之后的怒江峡谷30多公里，重点是老虎嘴路段。车开下去的话，第二天可以云南旅游了。\n109国道拉萨至安多是京藏高速的一部分，属于一级公路，非常好走。过了安多，呵呵，我反正不想开第二次。\n青甘大环线没有什么好讲的，都非常成熟了。唯一要说的，就是青海境内的高速和内地的不一样，有平交路口。内地的高速是全封闭全立交的。过平交路口的时候，千万记得减速。\n\n老虎嘴\n\n\n怒江峡谷\n\n\n109国道安多段\n\n\n109国道那曲段\n\n\n充电\n318国道西藏之前随便充。特来电、小鹏、蔚来、特斯拉和国家电网均有布局。318进西藏之后，国家电网几乎看不到，其他几家的桩沿途均有。拉萨往西，还有较少的特斯拉、蔚来。这里重点说一下九州可往小程序。这个在318国道日喀则市以西，深入到219国道阿里地区，是最常用的充电桩。每一个县城都有桩。另外，带上3.5Kw随车充，没准遇到特殊情况桩不能用，要到藏民家里充电。藏民非常淳朴，必要的礼节做到位，藏民们是非常友好的。\n\n\n\n\n109国道加电APP必装，特斯拉在这条线上已经看不到了，几乎只有蔚来，这里要强烈表扬蔚来！那曲、安多县城有较多的桩，其他地方桩非常少，旅游旺季不建议开电车自驾。当然这条路上也没什么自驾的人，全是百吨王。\n\n\n\n\n青甘大环线没什么特别要说的。就一点，走柳格高速，阿克塞哈萨克族自治县翻越阿尔金山进青海的时候，有一段连续的上坡，大约100km。电车要注意，别开巡航，车速80km&#x2F;h左右，这样刚好能到大柴旦。这段属于无人区，连个鸟都看不到，要是跑没电了，有苦头吃了。\n\n\n\n一些纯实用干货\n弯道不超车、不停车。\n天黑不行车，下雪不行车。百吨王司机传授给我的经验。\n带上防滑链，下雪了用得上。防滑链装驱动轮上，一定要自己先装一遍。\n318国道上的景点，带栏杆的停车场，大部分都是私人的，只要进去，就收费，没有免费停车时间。\n不要随意下铺装路面，运气好车和人都能回来，运气差点人能回来车回不来，运气再差点人车都回不来。 \n买好意外险，最好留下遗嘱。318国道塌方和落石路段还是有的，明天的太阳能不能看到谁也说不清楚，全看命。\n不要随意开车门，尤其是日喀则地区。单人、纯女生，更要注意人身安全。停车的时候碰到有人围着你车转，多留神。\n遇到牦牛、羊群挡路别按喇叭，远远的停车。一头牦牛三四万人民币，撞到一头可以原路返回了。\n进高原后，气压变低，胎压也会降低，及时补充胎压。别问我怎么知道的，我换了四条轮胎。\n别逞强，别脱衣服拍好看的照片，尤其是在109国道上。纳赤台得病，五道梁送命的事情，每年都有。\n遇到轮胎附近冒蒸汽的重卡，离远点。这是淋水器在工作，给刹车降温的。刹车过热后，制动距离会变长，所以要淋水降温。\n315国道有很多U型路段，短视频平台经常推坐在路中间打卡拍照的视频，这是送命的行为。重卡在这种路段需要冲坡，不然会上不去，所以下坡会踩油门。碰到人品好的司机，拉一把方向冲到路边撞车，运气不好碰到刹车热衰减的重卡，容易g。\n\n\n\n\n落石路段\n\n\n\n\n塌方路段\n\n\n\n\nU型路段\n\n\n\n一些风景照西部虽然自然环境恶劣，条件艰苦，但风景还是很美的。\n\n雪山\n\n\n海子山姊妹湖\n\n\n拉萨\n\n\n布达拉宫夜景\n\n\n珠穆朗玛峰日照金山\n\n\n羊卓雍错\n\n\n可可西里\n\n\n昆仑山\n\n\n青海湖\n\n\n\n\n\n天地、众生和自己，先见哪一个？ 佛说世界，既非世界，是名世界。——《金刚经》\n&nbsp;&nbsp;&nbsp;&nbsp;一个偶然的机会，去听了复旦大学王德峰讲《金刚经》。“三句义”虽然听得懂，但从来没切身感受过。再加上个体经历的迥然不同，有的人一生只见自己，有的人先见众生后见天地，所以很难对这三件事物有先后的排名。若以佛家的视角来看，见自己要远比见天地、见众生更难。事实上，正因为见天地、见众生，才得以见自己。我的人生脚本给的次序是：天地、众生、自己。现在来看，这样的次序，是有哲学上的深度的。禅宗里追根究底，不过求一个自家本来面目。天地、众生无非是外在的形象，外在形象为心所变。所有皆是眼上所见、心中所想。人生在不同的阶段，也会有不同的信仰。\n中国到底是什么样子的？ 当下的中国，依然是乡土性的。费孝通 —《乡土中国》\n《乡土中国》这本书是费孝通先生写于20世纪40年代。虽然中国的城镇化率已经接近70%，但书中很多对中国基层社会的描述放在当下也是非常合适的。本书虽然讲的是乡土社会，但深层理解，却是讲了很多我们礼俗习惯背后的原因。我在自驾之前就读过这本书，自驾回来对这本书中的观点感触颇深。费老从各个方面抽象的阐述了中国社会基层的样貌，我觉得对大家了解中国很有帮助。\n乡土本色这个“土”字，代表着土地、土气。每一片土地上生活的人们，都有着当地的土性。当我明白了这个“土”字的含义后惊奇的发现，我们的思想、理念、行为、习惯均来自土的特性。城市里生活的人们，朝九晚六，背负房贷，是每一片工业化、经济化的土地性质所决定的。西部山区里生活的少数民族，天黑就载歌载舞，天亮就放马、牧羊，是农业化的土地性质决定的。知识分子的小孩识字多，乡下的孩子认识五谷杂粮，还会捉蚱蜢。土地性质的不同，导致人们所持有能力的不同，而不是智力问题。原有的土地容纳的人数饱和后，过剩的人不得不向外迁徙。工业化的一个次要目的，就是解决农村过剩的人口。\n文字为什么上一代，上两代农村文盲多？以前我把原因归结于经济落后，教师资源短缺，却想不到农业人口本来就不需要学那么多文字。文字的本质是为了记录和传递信息，基层社会都是直接社交，并不需要文字。少数民族的牧民，一吹口哨，就表示牲畜要收栏回笼了。**群体越大，共同经验越有限，语言也简单。少数人之间，因为交往需要会形成特殊语言（行话）。**书中这个观点我体会颇深。城里人打招呼，用的是你好。河南农村里，民以食为天。“吃了吗？”就是你好的意思。我在109国道上和很多重卡司机聊过天，“飞车”：指柴油发动机转速失去控制，大大超过额定转速，排气管冒出大量黑烟或者蓝烟的故障。“开锅”：并不是水烧开了，而是爬坡时间太长，导致发动机冷却液被烧开了。“对齐、抓手、赋能、闭环……”，互联行业的特殊语言。\n男女有别\n乡土社会所求的是稳定。男女间的关系必须有一种安排，使他们之间不发生激动性的感情。稳定关系的力量，不是感情，而是了解。依现代文化来看，男女间感情激动的发达已使生育的事业摇摇欲坠。《乡土中国》p66、p69。\n\n这段异性之间关系的阐述，放在现代也不过时。土地性质决定人群所持有的能力，开放程度越高的城市，人群采用浮士德式的两性恋爱方式也越多，感情的激动程度也远高于西部农牧地区。因而导致离婚率升高、生育率下跌。\n写在最后写到这里了，已经很多文字了。最后让我想到的一句话：“读万卷书，行万里路”。行万里路，不仅仅是看风景，尝美食。更深层的含义是带着理论去实践。你们觉得呢？\n","categories":["生活"],"tags":["自驾 - 318国道 - 109国道 -  315国道"]},{"title":"调用方法和构造函数","url":"//technology/java/calling-methods-and-constructors/","content":"将信息传递给方法或构造函数方法或构造函数的声明用于指定该方法或构造函数的参数数量和类型。例如，以下方法根据贷款金额、利率、贷款期限（期数）以及贷款的未来价值来计算住房贷款的月供：\npublic double computePayment(\n                  double loanAmt,\n                  double rate,\n                  double futureValue,\n                  int numPeriods) &#123;\n    double interest = rate / 100.0;\n    double partial1 = Math.pow((1 + interest), \n                    - numPeriods);\n    double denominator = (1 - partial1) / interest;\n    double answer = (-loanAmt / denominator)\n                    - ((futureValue * partial1) / denominator);\n    return answer;\n&#125;\n\n该方法有四个参数：贷款金额、利率、未来价值和期数。前三者为双精度浮点数，第四个为整数。这些参数在方法主体中使用，运行时将采用传入的参数值。\n\n注意：参数指方法声明中的变量列表。参数值则是方法被调用时实际传递的值。调用方法时，使用的参数值必须在类型和顺序上与声明的参数匹配。\n\n参数类型方法或构造函数的参数可以使用任何数据类型。这包括基本数据类型（如双精度浮点数、浮点数和整数，正如你在 &lt;font color&#x3D;”#ea8b43”computePayment() 方法中所见），以及引用数据类型（如对象和数组）。\n以下是一个接受数组作为参数的方法示例。该方法创建新的 Polygon 对象，并从 Point 对象数组初始化（假设 Point 是表示 x、y 坐标的类）：\npublic Polygon polygonFrom(Point[] corners) &#123;\n    // method body goes here\n&#125;\n\n任意数量的参数你可以使用一种称为可变参数（varargs）的构造，向方法传递任意数量的值。当你无法确定将向方法传递多少个特定类型的参数时，就需要使用可变参数。它相当于手动创建数组的快捷方式（前文的方法本可使用可变参数替代数组实现）。要使用可变参数，需在最后一个参数类型后跟上省略号（三个点，…），接着加空格，再写参数名。这样该方法就能接受任意数量的该参数，包括零个参数。\npublic Polygon polygonFrom(Point... corners) &#123;\n    int numberOfSides = corners.length;\n    double squareOfSide1, lengthOfSide1;\n    squareOfSide1 = (corners[1].x - corners[0].x)\n                     * (corners[1].x - corners[0].x) \n                     + (corners[1].y - corners[0].y)\n                     * (corners[1].y - corners[0].y);\n    lengthOfSide1 = Math.sqrt(squareOfSide1);\n\n    // more method body code follows that creates and returns a \n    // polygon connecting the Points\n&#125;\n\n你可以看到，在方法内部，corners 被当作数组处理。该方法既可以接受数组参数，也可以接受序列参数。无论哪种情况，方法体中的代码都会将参数视为数组。你最常在打印方法中看到可变参数；例如这个 printf()方法：\npublic PrintStream printf(String format, Object... args)\n允许您打印任意数量的对象。调用方式如下：\nSystem.out.printf(\"%s: %d, %s%n\", name, idnum, address);\n或者这样\nSystem.out.printf(\"%s: %d, %s, %s, %s%n\", name, idnum, address, phone, email);\n或带有更多参数的版本。\n参数名称当你为方法或构造函数声明参数时，需要为该参数指定一个名称。该名称将在方法主体中用于引用传入的参数。参数名称在其作用域内必须唯一。它不能与同一方法或构造函数中的其他参数名称相同，也不能与方法或构造函数内部的局部变量名称相同。参数可以与类的字段同名。若出现这种情况，则称该参数遮蔽了字段。遮蔽字段会降低代码可读性，通常仅在构造函数和设置特定字段的方法中使用。例如，请看以下Circle 类及其 setOrigin() 方法：\npublic class Circle &#123;\n    private int x, y, radius;\n    public void setOrigin(int x, int y) &#123;\n        ...\n    &#125;\n&#125;\nCircle类包含三个字段：x、y和radius。setOrigin() 方法有两个参数，每个参数的名称都与其中一个字段相同。每个方法参数都会遮蔽与其同名的字段。因此在方法体内使用简单的 x 或 y 时，会引用参数而非字段。要访问字段，必须使用限定名。本课后续章节“使用 this 关键字”将对此进行详细说明。\n传递基本数据类型参数基础数据类型的参数（如 int 或 double）以值传递方式传入方法。这意味着对参数值的任何修改仅存在于方法作用域内。当方法返回时，这些参数便消失，对它们所做的任何修改都会丢失。以下是一个示例：\npublic class PassPrimitiveByValue &#123;\n    public static void main(String[] args) &#123;\n        int x = 3;\n\n        // invoke passMethod() with\n        // x as argument\n        passMethod(x);\n\n        // print x to see if its\n        // value has changed\n        IO.println(\"After invoking passMethod, x = \" + x);\n    &#125;\n\n    public static void passMethod(int p) &#123;\n        p = 10;\n    &#125;\n&#125;\n程序输出如下\nAfter invoking passMethod, x = 3\n\n传递引用数据类型参数引用数据类型参数（如对象）同样以值传递方式传入方法。这意味着当方法返回时，传入的引用仍指向原对象。但若具备相应访问权限，可在方法内部修改对象字段的值。例如，考虑某个任意类中移动 Circle 对象的方法：\npublic void moveCircle(Circle circle, int deltaX, int deltaY) &#123;\n    // code to move origin of circle to x+deltaX, y+deltaY\n    circle.setX(circle.getX() + deltaX);\n    circle.setY(circle.getY() + deltaY);\n        \n    // code to assign a new reference to circle\n    circle = new Circle(0, 0);\n&#125;\n让该方法使用以下参数被调用：\nmoveCircle(myCircle, 23, 56)\n在方法内部， circle 最初指向  myCircle 。该方法将  circle 所引用的对象（即  myCircle ）的  x 和  y 坐标分别改变为23和56。这些修改在方法返回后仍会持续生效。随后  circle 被赋予对新  Circle 对象的引用，其  x &#x3D; y &#x3D; 0 。然而这种重新赋值并不会持久化，因为该引用是以值传递方式传入的，无法改变。方法执行期间， circle 所指向的对象已发生变更，但方法返回时， myCircle 仍指向方法调用前的原始  Circle 对象。\n","categories":["技术","Java"],"tags":["Java Programming Language"]},{"title":"控制流语句","url":"//technology/java/control-flow-statements/","content":"If-Then 语句if-then 语句是所有控制流语句中最基础的一种。它指示程序仅在特定测试条件为真时执行某段代码。例如，Bicycle 类可规定刹车系统仅在自行车处于运动状态时才能降低车速。applyBrakes() 方法的一种可能实现如下：  \nvoid applyBrakes() &#123;\n    // the \"if\" clause: bicycle must be moving\n    if (isMoving) &#123;\n        // the \"the\" clause: decrease current speed \n        currentSpeed--;\n    &#125;\n&#125;\n\n\n\n如果此测试结果为 false（即自行车未处于运动状态），控制流将跳转至 if-then 语句的末尾。此外，当”then”子句仅包含一条语句时，开括号和闭括号可省略：\nvoid applyBrakes() &#123;\n    // same as above, but without braces\n    if (isMoving)\n        currentSpeed--;\n&#125;\n何时省略大括号取决于个人偏好。省略大括号会使代码更脆弱。若后续在”then”子句中添加第二条语句，常见错误便是忘记添加新需要的大括号。编译器无法检测此类错误，最终只会得到错误结果。\nIf-Then-Else 语句if-then-else 语句在”if”子句计算为 false 时提供次要执行路径。您可以在 applyBrakes() 方法中使用 if-then-else 语句，当自行车静止时仍触发刹车操作时执行特定动作。此处该动作仅需输出错误提示，说明自行车已处于静止状态。\nvoid applyBrakes() &#123;\n    if (isMoving) &#123;\n        currentSpeed--;\n    &#125; else &#123;\n        System.err.println(\"The bicycle has already stopped.\");\n    &#125;\n&#125;\n以下程序 IfElseDemo 根据考试分数的数值分配等级：90%及以上为 A，80%及以上为 B，依此类推。\npublic class IfElseDemo &#123;\n    public static void main(String[] args) &#123;\n        int testscore = 76;\n        char grade;\n\n        if (testscore >= 90) &#123;\n            grade = 'A';\n        &#125; else if (testscore >= 80) &#123;\n            grade = 'B';\n        &#125; else if (testscore >= 70) &#123;\n            grade = 'C';\n        &#125; else if (testscore >= 60) &#123;\n            grade = 'D';\n        &#125; else &#123;\n            grade = 'F';\n        &#125;\n\n        IO.println(\"Grade = \" + grade);\n    &#125;\n&#125;\n输出为\nGrade = C\n您可能注意到，testscore 的值可以同时满足复合语句中的多个表达式：76 &gt;&#x3D; 70 和 76 &gt;&#x3D; 60。然而，一旦某个条件成立，相应的语句 （grade &#x3D; ‘C’;） 就会被执行，其余条件将不再进行计算。\nWhile 和 Do-While 语句while 语句在特定条件为 true 时持续执行一组语句。其语法可表示为：\nwhile(condition)&#123;\n    statement(s);\n&#125;\nwhile 语句会评估表达式，该表达式必须返回布尔值。若表达式评估结果为真，则 while 语句执行 while 代码块中的语句。while 语句会持续测试表达式并执行其代码块，直至表达式评估结果为假。使用while 语句打印1至10的数值可通过以下 WhileDemo 程序实现：\npublic class WhileDemo &#123;\n    public static void main(String[] args) &#123;\n        int count = 1;\n        while (count &lt; 11) &#123;\n            IO.println(\"Count is: \" + count);\n            count++;\n        &#125;\n    &#125;\n&#125;\n你可以使用while语句实现无限循环，如下所示：\nwhile(true) &#123;\n    // your code goes here\n&#125;\nJava 编程语言还提供了 do-while 语句，其表达形式如下：\ndo &#123;\n    statement(s);\n&#125; while (expression);\ndo-while 与 while 的区别在于，do-while 在循环末尾而非开头评估其表达式。因此，do 代码块内的语句至少会执行一次，如下面的 DoWhileDemo 程序所示：\npublic class DoWhileDemo &#123;\n    public static void main(String[] args) &#123;\n        int count = 1;\n        do &#123;\n            IO.println(\"Count is: \" + count);\n            count++;\n        &#125; while (count &lt; 11);\n    &#125;\n&#125;\n\nFor 语句for 语句提供了一种紧凑的方式来遍历一组值。程序员常将其称为”for循环”，因为它会反复循环直至某个特定条件满足。for 语句的一般形式可表示如下：\nfor(initialization; termination; iteration)&#123;\n    statement(s);\n&#125;\n使用此版本的 for 语句时，请注意：\n\n初始化表达式用于初始化循环；它在循环开始时执行一次。\n当终止表达式评估为 false 时，循环终止。\n增量表达式在每次循环迭代后被调用；该表达式对值进行递增或递减操作是完全可行的。\n\n以下程序 ForDemo 使用 for 语句的一般形式，将数字 1 到 10 打印到标准输出：\npublic class ForDemo &#123;\n    public static void main(String[] args) &#123;\n        for (int i = 1; i &lt; 11; i++) &#123;\n            IO.println(\"Count is : \" + i);\n        &#125;\n    &#125;\n&#125;\n这个程序的输出是：\nCount is : 1\nCount is : 2\nCount is : 3\nCount is : 4\nCount is : 5\nCount is : 6\nCount is : 7\nCount is : 8\nCount is : 9\nCount is : 10\n请注意代码如何在初始化表达式中声明变量。该变量的作用域从声明处延伸至 for 语句所控制的代码块末尾，因此也可用于终止条件和递增表达式中。若控制 for 语句的变量在循环外部无需使用，最佳做法是在初始化表达式中声明该变量。变量名 i、j 和 k 常用于控制 for 循环；在初始化表达式中声明它们可限制其作用域并减少错误。\nfor 循环的三个表达式都是可选的；无限循环可按以下方式创建：\n// infinite loop\nfor(; ;)&#123;\n    // your code goes here\n&#125;\nfor 语句还提供另一种形式，专用于遍历集合和数组。这种形式有时被称为增强型 for 语句，可使循环代码更紧凑且易于阅读。以下是一个存储 1 到 10 的数组作为示例：\nint[] numbers = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;;\n以下程序 EnhancedForDemo 使用增强的 for 循环遍历数组：\npublic class EnhancedForDemo &#123;\n    public static void main(String[] args) &#123;\n        int[] numbers = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;;\n        for (int item : numbers) &#123;\n            IO.println(\"Count is: \" + item);\n        &#125;\n    &#125;\n&#125;\n在此示例中，变量 item 存储了 numbers 数组的当前值。该程序的输出结果与之前相同：\nCount is: 1\nCount is: 2\nCount is: 3\nCount is: 4\nCount is: 5\nCount is: 6\nCount is: 7\nCount is: 8\nCount is: 9\nCount is: 10\n我们建议在可能的情况下，优先使用这种形式的 for 语句，而非通用形式。\nBreak 语句break 语句有两种形式：带标签的和不带标签的。在前文关于 switch 语句的讨论中，你已经见过不带标签的形式。你也可以使用不带标签的 break 语句来终止 for、while 或 do-while 循环，如下面的 BreakDemo 程序所示：\npublic class BreakDemo &#123;\n    public static void main(String[] args) &#123;\n        int[] arrayOfInts\n                = &#123;32, 87, 3, 589,\n                    12, 1076, 2000,\n                    8, 622, 127&#125;;\n        int searchfor = 12;\n\n        int i;\n        boolean foundIt = false;\n\n        for (i = 0; i &lt; arrayOfInts.length; i++) &#123;\n            if (arrayOfInts[i] == searchfor) &#123;\n                foundIt = true;\n                break;\n            &#125;\n        &#125;\n        if (foundIt) &#123;\n            IO.println(\"Found \" + searchfor + \" at index \" + i);\n        &#125; else &#123;\n            IO.println(searchfor + \" not in array\");\n        &#125;\n    &#125;\n&#125;\n\n该程序在数组中搜索数字12。当找到该值时，break 语句将终止 for 循环。控制流随后转移到for循环后的语句。该程序的输出为：\nFound 12 at index 4\n未标记的 break 语句会终止最内层的 switch、for、while 或 do-while 语句，而带标签的 break则会终止外层语句。以下程序 BreakWithLabelDemo 与前例类似，但使用嵌套 for 循环在二维数组中搜索值。当找到目标值时，带标签的break 会终止外层 for 循环（标记为”search”）：\npublic class BreakWithLabelDemo &#123;\n    public static void main(String[] args) &#123;\n        int[][] arrayOfInts = &#123;\n            &#123;32, 87, 3, 589&#125;,\n            &#123;12, 1076, 2000, 8&#125;,\n            &#123;622, 127, 77, 955&#125;\n        &#125;;\n\n        int searchfor = 12;\n\n        int i;\n        int j = 0;\n        boolean foundIt = false;\n\n        search:\n        for (i = 0; i &lt; arrayOfInts.length; i++) &#123;\n            for (j = 0; j &lt; arrayOfInts[i].length; j++) &#123;\n                if (arrayOfInts[i][j] == searchfor) &#123;\n                    foundIt = true;\n                    break search;\n                &#125;\n            &#125;\n        &#125;\n\n        if (foundIt) &#123;\n            IO.println(\"Found \" + searchfor + \" at index \" + i + \", \" + j);\n        &#125; else &#123;\n            IO.println(searchfor + \" not in the array\");\n        &#125;\n    &#125;\n&#125;\n该程序的输出为：\nFound 12 at index 1, 0\nbreak 语句终止标记语句的执行；它不会将控制流转移到标记处。控制流将转移到标记语句（终止语句）之后紧接的语句。Java 中的标签（Label 必须紧接在它所引用的语句或块（Block）之前，并且它的作用范围仅限于它所标记的语句或块本身。\nContinue 语句continue 语句用于跳过 for、while 或 do-while 循环的当前迭代。无标签形式会跳至最内层循环体的末尾，并评估控制循环的布尔表达式。以下程序 ContinueDemo 遍历字符串，统计字母 p 的出现次数。若当前字符非 p，则 continue 语句跳过循环剩余部分并处理下一个字符；若为 p，则程序递增字母计数。\npublic class ContinueDemo &#123;\n    public static void main(String[] args) &#123;\n        String searchMe = \"peter piper picked a \" + \"peck of pickled peppers\";\n        int max = searchMe.length();\n        int numPs = 0;\n\n        for (int i = 0; i &lt; max; i++) &#123;\n            if (searchMe.charAt(i) != 'p') &#123;\n                continue;\n            &#125;\n            numPs++;\n        &#125;\n        IO.println(\"Found \" + numPs + \" p's in the string.\");\n    &#125;\n&#125;\n程序输出为：\nFound 9 p's in the string.\n要更清楚地看到这种效果，请尝试删除 continue 语句并重新编译。再次运行程序时，计数结果将出错，显示找到 35 个字母 p 而不是 9 个。带标签的 continue 语句会跳过当前外层循环中带有该标签的迭代。以下示例程序 ContinueWithLabelDemo 使用嵌套循环在字符串中搜索子字符串。需要两个嵌套循环：一个遍历子字符串，另一个遍历待搜索的字符串。该程序通过带标签的 continue 测试跳过外层循环的迭代。\npublic class ContinueWithLabelDemo &#123;\n    public static void main(String[] args) &#123;\n        String searchMe = \"Look for a substring in this string.\";\n        String subString = \"str\";\n        boolean foundIt = false;\n\n        int max = searchMe.length() - subString.length();\n\n        test:\n        for (int i = 0; i &lt;= max; i++) &#123;\n            int n = subString.length();\n            int j = i;\n            int k = 0;\n            while (n-- != 0) &#123;\n                if (searchMe.charAt(j++) != subString.charAt(k++)) &#123;\n                    continue test;\n                &#125;\n            &#125;\n            foundIt = true;\n            break test;\n        &#125;\n        IO.println(foundIt ? \"Found it\" : \"Didn't find it\");\n    &#125;\n&#125;\n该程序的输出为：\nFound it\nReturn 语句下一个分支语句是 return 语句。return 语句将退出当前方法，控制流返回至方法被调用的位置。return 语句有两种形式：一种返回值，另一种不返回值。要返回值，只需在 return 关键字后放置该值（或计算该值的表达式）。\nreturn ++count;\n返回值的数据类型必须与方法声明的返回值类型一致。当方法声明为 void 时，请使用不返回值的 return 形式。\nreturn;\n类与对象章节将涵盖编写方法所需掌握的所有知识。\nYield 语句最后一个分支语句是 yield 语句。yield 语句将退出当前所在的 switch 表达式。yield 语句之后必须跟随一个能产生值的表达式，该表达式不能为 void 类型。此表达式的值即为包含它的 switch 表达式所产生的值。以下是一个 yield 语句的示例。写这个代码的人正在计算还要上几天班。\npublic class YieldDemo &#123;\n\n    enum Day &#123;\n        MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY\n    &#125;\n\n    public int calculate(Day d) &#123;\n        return switch (d) &#123;\n            case SATURDAY, SUNDAY -> 0;\n            default -> &#123;\n                int remindingWorkDays = 5 - d.ordinal();\n                yield remindingWorkDays;\n            &#125;\n        &#125;;\n    &#125;\n&#125;","categories":["技术","Java"],"tags":["Java Programming Language"]},{"title":"创建和使用对象","url":"//technology/java/creating-and-using-objects/","content":"理解什么是对象典型的Java程序会创建大量对象，这些对象通过调用方法进行交互。通过这种对象交互，程序能够执行各种任务，例如实现图形用户界面、运行动画，或在网络上发送和接收信息。当对象完成其创建时的任务后，其资源将被回收供其他对象使用。这是一个名为 CreateObjectDemo 的小程序，它创建了三个对象：一个 Point 对象和两个 Rectangle 对象。您需要所有三个源文件才能编译此程序。\n\npublic class CreateObjectDemo &#123;\n    public static void main(String[] args) &#123;\n        // Declare and create a point object and two rectangle objects.\n        Point originOne = new Point(23, 94);\n        Rectangle rectOne = new Rectangle(originOne, 100, 200);\n        Rectangle rectTwo = new Rectangle(50, 100);\n\n        // display rectOne's width, height, and area\n        IO.println(\"Width of rectOne: \" + rectOne.width);\n        IO.println(\"Height of rectOne: \" + rectOne.height);\n        IO.println(\"Area of rectOne: \" + rectOne.getArea());\n\n        // set rectTwo's position\n        rectTwo.origin = originOne;\n\n        // display rectTwo's position\n        IO.println(\"X position of rectTwo: \" + rectTwo.origin.x);\n        IO.println(\"Y position of rectTwo: \" + rectTwo.origin.y);\n\n        // move rectTwo and display its new position\n        rectTwo.move(40, 72);\n        IO.println(\"X position of rectTwo: \" + rectTwo.origin.x);\n        IO.println(\"Y position of rectTwo: \" + rectTwo.origin.y);\n    &#125;\n&#125;\nPoint 类\npublic class Point &#123;\n    public int x = 0;\n    public int y = 0;\n\n    public Point(int x, int y) &#123;\n        this.x = x;\n        this.y = y;\n    &#125;\n&#125;\n\nRectangle 类\npublic class Rectangle &#123;\n    public int width = 0;\n    public int height = 0;\n    public Point origin;\n\n    // four constructors\n    public Rectangle() &#123;\n        origin = new Point(0, 0);\n    &#125;\n\n    public Rectangle(Point p) &#123;\n        origin = p;\n    &#125;\n\n    public Rectangle(int w, int h) &#123;\n        origin = new Point(0, 0);\n        width = w;\n        height = h;\n    &#125;\n\n    public Rectangle(Point p, int w, int h) &#123;\n        origin = p;\n        width = w;\n        height = h;\n    &#125;\n\n    // a method for moving the rectangle\n    public void move(int x, int y) &#123;\n        origin.x = x;\n        origin.y = y;\n    &#125;\n\n    // a method for computing the area of the rectangle\n    public int getArea() &#123;\n        return width * height;\n    &#125;\n&#125;\n该程序用于创建、操作和显示各类对象的相关信息。输出结果如下：\nWidth of rectOne: 100\nHeight of rectOne: 200\nArea of rectOne: 20000\nX position of rectTwo: 23\nY position of rectTwo: 94\nX position of rectTwo: 40\nY position of rectTwo: 72\n以下三个部分将通过上述示例阐述对象在程序中的生命周期。通过这些内容，您将学会如何编写代码在自己的程序中创建和使用对象，同时了解系统如何在对象生命周期结束时进行清理工作。\n创建对象众所周知，类为对象提供了蓝图；你从类中创建对象。以下摘自 CreateObjectDemo 程序的每条语句都会创建一个对象并将其赋值给变量：\nPoint originOne = new Point(23, 94);\nRectangle rectOne = new Rectangle(originOne, 100, 200);\nRectangle rectTwo = new Rectangle(50, 100);\n第一行创建了 Point 类的对象，第二行和第三行分别创建了 Rectangle 类的对象。每条陈述都包含三个部分（详见下文）：\n\nDeclaration： 粗体标注的代码均为变量声明，用于将变量名与对象类型关联。\nInstantiation： new 关键字是创建对象的 Java 运算符。\nInitialization： new 运算符之后紧跟构造函数调用，该构造函数用于初始化新对象。\n\n声明一个变量指向一个对象之前你学过，要声明一个变量，你写：\ntype name;\n此声明告知编译器，您将使用名称name来引用类型为type的数据。对于原始变量，此声明还会为该变量预留适当的内存空间。你也可以在单独一行声明引用变量。例如：\nPoint originOne;\n若像这样声明 originOne，其值将保持未确定状态，直到实际创建对象并赋值给它。仅声明引用变量并不会创建对象。为此，你需要使用 new 运算符，具体方法将在下一节说明。在代码中使用 originOne 之前，必须先为其赋值。否则将引发编译器错误。此状态下的变量当前未引用任何对象。\n实例化一个类new 运算符通过为新对象分配内存并返回该内存的引用来实例化类。new 运算符还会调用对象构造函数。\n\n注意：“instantiating a class”与“creating an object.”是同义的。当你创建对象时，实际上是在创建类的“实例”，因此也实现了对类的“实例化”。new 运算符需要一个后置参数：对构造函数的调用。构造函数的名称即为待实例化的类名。new 操作符返回其创建的对象的引用。该引用通常会被赋值给相应类型的变量，例如：\n\nPoint originOne = new Point(23, 94);\nnew 操作符返回的引用不必赋值给变量，也可直接用于表达式中。例如：\nint height = new Rectangle().height;\n这个语句将在下一节中进行讨论。\n初始化新对象这里是 Point 类的代码：\npublic class Point &#123;\n    public int x = 0;\n    public int y = 0;\n    //constructor\n    public Point(int a, int b) &#123;\n        x = a;\n        y = b;\n    &#125;\n&#125;\n该类包含一个构造函数。构造函数的声明与类名相同且无返回类型，因此可通过此特征识别。Point 类的构造函数接受两个整数参数，代码声明为 Point(int a, int b)。以下语句为这些参数赋值23和94：\nPoint originOne = new Point(23, 94);\n执行此语句的结果可通过下图说明：以下是 Rectangle 类的代码，其中包含四个构造函数：\npublic class Rectangle &#123;\n    public int width = 0;\n    public int height = 0;\n    public Point origin;\n\n    // four constructors\n    public Rectangle() &#123;\n        origin = new Point(0, 0);\n    &#125;\n    \n    public Rectangle(Point p) &#123;\n        origin = p;\n    &#125;\n    \n    public Rectangle(int w, int h) &#123;\n        origin = new Point(0, 0);\n        width = w;\n        height = h;\n    &#125;\n    \n    public Rectangle(Point p, int w, int h) &#123;\n        origin = p;\n        width = w;\n        height = h;\n    &#125;\n\n    // a method for moving the rectangle\n    public void move(int x, int y) &#123;\n        origin.x = x;\n        origin.y = y;\n    &#125;\n\n    // a method for computing the area of the rectangle\n    public int getArea() &#123;\n        return width * height;\n    &#125;\n&#125;\n\n每个构造函数都允许您为矩形的 origin、width和height提供初始值，既可使用基本类型，也可使用引用类型。如果一个类有多个构造函数，它们必须具有不同的签名。Java编译器根据参数的数量和类型来区分构造函数。当Java编译器遇到以下代码时，它会知道调用 Rectangle 类中需要一个 Point 参数后跟两个整数参数的构造函数：\nRectangle rectOne = new Rectangle(originOne, 100, 200);\n\n这调用了矩形的一个构造函数，该函数将 origin 初始化为 originOne 。同时，构造函数将宽度设置为100，高度设置为200。现在存在两个指向同一个 Point对象的引用——一个对象可以拥有多个引用，如下图所示：\n以下代码行调用了 Rectangle 类构造函数，该构造函数需要两个整数参数，用于提供宽度和高度的初始值。若检查构造函数内部的代码，你会发现它创建了一个新的 Point 对象，其x和y值初始化为0：\nRectangle rectTwo = new Rectangle(50, 100);\n以下语句中使用的矩形构造函数不接受任何参数，因此称为无参数构造函数：\nRectangle rect = new Rectangle();\n所有类至少包含一个构造函数。若类未显式声明构造函数，Java编译器会自动提供一个无参构造函数，称为默认构造函数。该默认构造函数会调用父类的无参构造函数；若该类无父类，则调用 Object 类的构造函数。若父类未定义构造函数（Object类确实存在），编译器将拒绝该程序。\n使用对象创建对象后，您可能需要使用它来完成某些操作。这可能包括：获取某个字段的值、修改某个字段，或是调用某个方法来执行特定操作。\n引用对象的字段对象字段通过其名称访问。必须使用明确无歧义的名称。\n在类内部，字段可使用简单名称。例如，我们可以在 Rectangle 类中添加语句以打印 width 和 height：\nIO.println(\"Width and height are: \" + width + \", \" + height);\n在此情况下，width 和 height 是简单名称。位于对象类外部的代码必须使用对象引用或表达式，后跟点(.)运算符，再接一个简单字段名，例如：\nobjectReferenace.fieldName\n例如，CreateObjectDemo 类中的代码位于 Rectangle 类代码之外。因此，要引用名为 rectOne 的 Rectangle 对象中的原点、宽度和高度字段，CreateObjectDemo 类必须分别使用名称 rectOne.origin、rectOne.width 和 rectOne.height。程序使用其中两个名称来显示 rectOne 的宽度和高度：\nIO.println(\"Width of rectOne: \"  + rectOne.width);\nIO.println(\"Height of rectOne: \" + rectOne.height);\n尝试在 CreateObjectDemo 类的代码中使用 width 和 height 这类简单名称是没有意义的——这些字段仅存在于对象内部——且会导致编译器报错。\n随后，程序使用类似代码显示 rectTwo 的相关信息。同类型的对象各自拥有相同的实例字段副本。因此，每个矩形对象都包含名为origin、width和height的字段。当通过对象引用访问实例字段时，你实际引用的是该特定对象的字段。在 CreateObjectDemo 程序中，两个对象 rectOne 和 rectTwo 各自拥有不同的 origin、width 和 height 字段。\n要访问字段，您可以使用对象的命名引用（如前例所示），也可以使用任何返回对象引用的表达式。请记住，new 运算符会返回对象的引用。因此，您可以使用 new 返回的值来访问新对象的字段：\nint height = new Rectangle().height;\n该语句创建了一个新的 Rectangle 对象，并立即获取其 height。本质上，该语句计算了 Rectangle 对象的默认高度。请注意，执行此语句后，程序不再持有创建的 Rectangle 对象的引用，因为程序从未将该引用存储在任何位置。该对象处于无引用状态，其资源可由Java虚拟机回收利用。\n调用对象的方法您还可通过对象引用调用对象的方法。在对象引用后添加方法的简单名称，中间用点运算符(.)连接。同时需在括号内提供方法的参数。若方法无需参数，则使用空括号。\nobjectReference.methodName(argumentList);\n或者\nobjectReference.methodName();\nRectangle 类包含两个方法： getArea() 用于计算矩形面积，move() 用于改变矩形原点位置。以下是调用这两个方法的 CreateObjectDemo代码：\nIO.println(\"Area of rectOne: \" + rectOne.getArea());\n...\nrectTwo.move(40, 72);\n\n第一条语句调用 rectOne 的 getArea() 方法并显示结果。第二行移动 rectTwo，因为 move() 方法为对象的 origin.x 和 origin.y 赋予了新值。与实例字段类似，objectReference 必须是对象的引用。你可以使用变量名，也可以使用任何返回对象引用的表达式。new 运算符返回对象引用，因此你可以使用 new 返回的值来调用新对象的方法：\nnew Rectangle(100, 50).getArea()\n\n表达式 new Rectangle(100, 50) 返回一个对象引用，该引用指向一个 Rectangle 对象。如所示，您可以使用点表示法调用新矩形的 getArea() 方法来计算新矩形的面积。\n某些方法（如 getArea()）会返回一个值。对于返回值的方法，您可以在表达式中使用方法调用。您可以将返回值赋给变量，用其进行决策，或控制循环。以下代码将 getArea() 返回的值赋给变量 areaOfRectangle：\nint areaOfRectangle = new Rectangle(100, 50).getArea();\n在此情况下，调用 getArea() 的对象是构造函数返回的矩形。\n垃圾回收器某些面向对象的语言要求你跟踪所有创建的对象，并在不再需要时显式销毁它们。显式管理内存既繁琐又容易出错。Java平台允许创建任意数量的对象（当然受系统承载能力的限制），且无需担心销毁问题。当Java运行时环境判定对象不再被使用时，会自动将其删除。这一过程称为垃圾回收。当对象不再被任何引用时，该对象即可进入垃圾回收阶段。变量持有的引用通常会在变量作用域结束时自动释放。或者，您也可以通过将变量赋值为特殊值 null 来显式释放对象引用。请注意，程序中可能存在多个指向同一对象的引用；只有当所有引用都被释放后，该对象才具备进入垃圾回收的资格。Java运行时环境配备了垃圾回收器，该机制会定期释放不再被引用的对象所占用的内存。当垃圾回收器判断时机成熟时，便会自动执行清理工作。\n","categories":["技术","Java"],"tags":["Java Programming Language"]},{"title":"枚举类型","url":"//technology/java/enums/","content":"Enums 是什么？枚举是所有实例均被编译器所知的类。它们用于创建仅能取少数可能值的类型。枚举的创建方式与类类似，但需使用枚举关键字（enum）替代类关键字（class）。枚举主体中包含一组称为枚举常量的实例列表，各常量以逗号分隔。除枚举常量之外，无法创建枚举的其他实例。\npublic enum DayOfWeek &#123;\n    // enum constants are listed here:\n    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY\n&#125;\n所有枚举类型都隐式继承自 java.lang.Enum，且不能有任何子类。\n\n\n访问、计算和比较枚举类型枚举的值可作为常量使用。要检查两个枚举实例是否相等，可使用&#x3D;&#x3D;运算符\nDayOfWeek day = DayOfWeek.MONDAY;\nif(weekStart == DayOfWeek.MONDAY) &#123;\n    IO.println(\"The week starts on Monday.\");\n&#125;\n也可以使用switch语句根据枚举值的不同来执行相应的操作。\nDayOfWeek someDay = DayOfWeek.FRIDAY\nswitch (someDay) &#123;\n    case MONDAY -> IO.println(\"The week just started.\");\n    case TUESDAY,WEDNESDAY,THURSDAY -> IO.println(\"We are somewhere in the middle of the week.\");\n    case FRIDAY -> IO.println(\"The weekend is near.\");\n    case SATURDAY,SUNDAY -> IO.println(\"Weekend\");\n    default -> throw new  AssertionError(\"Should not happen\");\n&#125;\n使用switch expressions，编译器可检查枚举的所有值是否均被处理。若switch expressions遗漏任何可能的值，将引发编译器错误。此特性称为穷尽性，也可通过JEP 409：Sealed Classes与[pattern matching][https://dev.java/learn/pattern-matching/#switch]在常规类中实现。\nDayOfWeek someDay = DayOfWeek.FRIDAY;\n\nString text = switch (someDay) &#123;\n    case MONDAY ->\n        \"The week just started.\";\n    case TUESDAY, THURSDAY ->\n        \"We are somewhere in the middle of the week.\";\n    case FRIDAY ->\n        \"The weekend is near.\";\n    case SATURDAY, SUNDAY ->\n        \"Weekend\";\n&#125;;\n上面这个例子会报错\nthe switch expression does not cover all possible input values\n\n向枚举添加成员与类类似，枚举也可以拥有构造函数、方法和字段。要添加这些内容，必须在枚举常量列表后添加分号。构造函数的参数在枚举常量声明后的括号内传递。\npublic enum DayOfWeek &#123;\n    // enum constants are listed here:\n    MONDAY(\"MON\"), TUESDAY(\"TUE\"), WEDNESDAY(\"WED\"), THURSDAY(\"THU\"), FRIDAY(\"FRI\"), SATURDAY(\"SAT\"), SUNDAY(\"SUN\");\n\n    private final String abbreviation;\n\n    DayOfWeek(String abbreviation) &#123;\n        this.abbreviation = abbreviation;\n    &#125;\n\n    public String getAbbreviation() &#123;\n        return abbreviation;\n    &#125;\n&#125;\n\n特殊方法所有枚举类型都隐式添加了若干方法。例如，方法 name() 存在于所有枚举实例中，可用于获取枚举常量的名称。同样，名为 ordinal() 的方法会返回枚举常量在声明中的位置。\nIO.println(DayOfWeek.MONDAY.name());    // prints \"MONDAY\"\nIO.println(DayOfWeek.MONDAY.ordinal()); // prints \"0\" because MONDAY is the first constant in the DayOfWeek enum\n除了实例方法外，所有枚举类型还添加了静态方法。values() 方法返回包含该枚举所有实例的数组，而 valueOf(String) 方法可通过名称获取特定实例。\nDayOfWeek[] days = DayOfWeek.values();\nDayOfWeek monday = DayOfWeek.valueOf(\"MONDAY\");\n此外，枚举实现了Comparable接口。默认情况下，枚举会根据其序号排序，即按枚举常量出现的顺序排列。这使得枚举实例的比较、排序和搜索成为可能。\npublic void compareDayOfWeek(DayOfWeek dayOfWeek) &#123;\n   int comparison = dayOfWeek.compareTo(DayOfWeek.MONDAY);\n   if (comparison &lt; 0) &#123;\n       IO.println(\"It's before the middle of the work week.\");\n   &#125; else if (comparison > 0) &#123;\n       IO.println(\"It's after the start of the work week.\");\n   &#125; else &#123;\n       IO.println(\"It's the middle of the work week.\");\n   &#125;\n&#125;\nList&lt;DayOfWeek> dayList = new ArrayList&lt;>(List.of(DayOfWeek.FRIDAY, DayOfWeek.TUESDAY, DayOfWeek.SUNDAY));\nCollections.sort(dayList);\n\n使用枚举类型创建单例由于枚举只能拥有特定数量的实例，因此可以通过创建仅包含单个枚举常量的枚举来实现单例模式。\npublic enum SingletonByEnum &#123;\n    INSTANCE;\n&#125;\n\n枚举类的抽象方法尽管枚举无法被扩展，但它们仍可包含抽象方法。在这种情况下，每个枚举常量都必须提供具体实现。\npublic enum MyEnum &#123;\n    A() &#123;\n        @Override\n        void doSomething() &#123;\n            IO.println(\"A\");\n        &#125;\n    &#125;,\n    B() &#123;\n        @Override\n        void doSomething() &#123;\n            IO.println(\"B\");\n        &#125;\n    &#125;;\n    \n    abstract void doSomething();\n&#125;\n\n注意事项在使用枚举时需谨慎，尤其当枚举项的数量（或名称）可能发生变化时。每当枚举常量被修改，其他依赖旧版枚举的代码都可能出现异常行为。这可能表现为编译错误（例如引用已被移除的枚举常量）、运行时错误（例如存在默认情况处理，但新枚举常量应单独处理）或其他不一致问题（例如枚举值被保存至文件，后续读取时仍期望该值存在）。\n修改枚举常量时，建议审查所有使用该枚举的代码。当该枚举也被他人代码使用时，此项操作尤为重要。\n此外，当实例数量较多时，或许值得考虑采用其他方案，因为在代码中单一位置列举大量实例可能缺乏灵活性。例如，在这种情况下，使用配置文件列出所有实例并在程序中读取这些配置文件可能更为理想。\n结束枚举提供了一种简单且安全的方式来表示一组固定的常量，同时保留了类的大部分灵活性。它们是一种特殊的类，可用于编写优雅、易读、易维护的代码，并能与其他现代Java特性（如switch表达式）良好配合。另一种特殊类是 Record，该特性在Java 16中作为预览功能引入，并在Java 16正式成为标准特性。访问我们的记录教程以了解更多信息。\n要了解更多关于枚举的信息，请访问 java.lang.Enum 的 javadoc。\n","categories":["技术","Java"],"tags":["Java Programming Language"]},{"title":"Expressions,Statements and Blocks","url":"//technology/java/expressions-statements-blocks/","content":"表达式表达式是由变量、运算符和方法调用构成的结构，这些元素遵循语言语法规则组合而成，最终求解为单一值。你已经见过表达式的实例，如下代码所示：\nint cadence = 0;\nanArray[0] = 100;\nIO.println(\"Element 1 at index 0: \" + anArray[0]);\n\nint result = 1 + 2; // result is now 3\nif (value1 == value2)&#123;\n    IO.println(\"value1  == value2\");\n&#125;\n\n表达式返回值的数据类型取决于表达式中使用的元素。表达式 cadence &#x3D; 0 返回 int 类型，因为赋值运算符返回的值与其左操作数具有相同数据类型；在此例中，cadence 是 int 类型。从其他表达式可见，表达式也可返回其他类型的值，例如布尔值或字符串。\nJava编程语言允许你将多个较小的表达式组合成复合表达式，前提是表达式各部分所需的数据类型相互匹配。以下是一个复合表达式的示例：\n1 * 2 * 3;\n在此特定示例中，表达式的求值顺序并不重要，因为乘法结果与顺序无关；无论采用何种顺序进行乘法运算，结果始终相同。然而，并非所有表达式都如此。例如，以下表达式根据先执行加法还是除法操作，会产生不同的结果：\nx + y / 100; // ambiguous\n你可以使用平衡括号（和）精确指定表达式的求值方式。例如，为消除前一个表达式的歧义，可改写为：\n(x + y) / 100; // unambiguous, recommended\n若未明确指定运算顺序，则由表达式中运算符的优先级决定。优先级较高的运算符将优先进行求值。例如，除法运算符的优先级高于加法运算符。因此，以下两条语句是等效的：\nx + y / 100; // ambiguous\nx + (y / 100); // unambiguous, recommended\n在编写复合表达式时，请明确使用括号标注应优先运算的运算符。此做法能使代码更易于阅读和维护。\n浮点运算浮点运算是一个特殊的世界，其中常见操作可能会表现出意想不到的行为。请看以下代码。\ndouble d1 = 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1;\nIO.println(\"d1 == 1 ? \" + (d1 == 1.0)); \n你可能会认为它会输出 true。但由于浮点数加法运算及舍入规则的影响，实际输出结果为 false。本教程不涉及Java中浮点运算的具体实现方式。若需深入了解该主题，可观看以下视频。\n\n\n语句语句大致相当于自然语言中的句子。一个语句构成完整的执行单元。以下类型的表达式可通过在表达式末尾添加分号（;）转换为语句：\n\n赋值表达式\n任何使用 ++ 或者 – 运算符的表达式\n方法调用表达式\n对象创建表达式\n此类语句称为表达式语句。以下是一些表达式语句的示例。\n\n// assignment statement\naValue = 8933.234;\n\n// increment statement\naValue++;\n\n// method invocation statement\nIO.println(\"Hello, World!\");\n\n// object creation statement\nBicycle myBike = new Bicycle();\n除了表达式语句外，还有另外两种语句：声明语句和控制流语句。声明语句用于声明变量。你已经见过许多声明语句的例子：\n// declaration satement\ndouble aValue = 8933.234;\n最后，控制流语句用于控制语句的执行顺序。您将在下一节“控制流语句”中学习相关知识。\n代码块代码块是由一组零个或多个语句组成的结构，这些语句被配对的大括号包围，可在允许单个语句的任何位置使用。以下示例 BlockDemo 演示了代码块的用法：\npublic class BlockDemo &#123;\n    public static void main(String[] args) &#123;\n        boolean condition = true;\n        if (condition) &#123; // begin block 1\n            IO.println(\"Condition is true\");\n        &#125;// end block one\n        else &#123; // begin block 2\n            IO.println(\"Condition is false\");\n        &#125; // end block 2\n    &#125;\n&#125;","categories":["技术","Java"],"tags":["Java Programming Language"]},{"title":"创建Class","url":"//technology/java/creating-classes/","content":"在题为 “对象、类与接口”的章节中，我们通过 Bicycle 类作为面向对象概念的入门示例，其中racing bikes、mountain bikes和tandem bikes分别作为子类。以下是 Bicycle 类的实现示例代码，旨在帮助您了解类声明的基本框架。后续章节将逐步回溯并详细解释类声明的具体实现。目前请不必过多关注细节。\n\npublic class Bicycle &#123;\n        \n    // the Bicycle class has\n    // three fields\n    public int cadence;\n    public int gear;\n    public int speed;\n        \n    // the Bicycle class has\n    // one constructor\n    public Bicycle(int startCadence, int startSpeed, int startGear) &#123;\n        gear = startGear;\n        cadence = startCadence;\n        speed = startSpeed;\n    &#125;\n        \n    // the Bicycle class has\n    // four methods\n    public void setCadence(int newValue) &#123;\n        cadence = newValue;\n    &#125;\n        \n    public void setGear(int newValue) &#123;\n        gear = newValue;\n    &#125;\n        \n    public void applyBrake(int decrement) &#123;\n        speed -= decrement;\n    &#125;\n        \n    public void speedUp(int increment) &#123;\n        speed += increment;\n    &#125;\n&#125;\n一个继承自Bicycle类的 MountainBike 类的声明可能如下所示：\npublic class MountainBike extends Bicycle &#123;\n        \n    // the MountainBike subclass has\n    // one field\n    public int seatHeight;\n    // the MountainBike subclass has\n    // one constructor\n    public MountainBike(int startHeight, int startCadence,\n                        int startSpeed, int startGear) &#123;\n        super(startCadence, startSpeed, startGear);\n        seatHeight = startHeight;\n    &#125;   \n        \n    // the MountainBike subclass has\n    // one method\n    public void setHeight(int newValue) &#123;\n        seatHeight = newValue;\n    &#125;   \n&#125;\nMountainBike 继承了 Bicycle 的所有字段和方法，并新增了seatHeight字段及其设置方法（山地车座椅可根据地形需求上下调节）。你可能见过以下定义的类：\nclass MyClass &#123;\n    // field, constructor, and method declarations\n&#125;\n这是一个类声明。类主体（大括号之间的区域）包含所有为该类创建的对象的生命周期提供支持的代码：用于初始化新对象的构造函数、声明类及其对象状态的字段声明，以及实现类及其对象行为的方法。上述类声明是最简形式，仅包含类声明所需的必要组件。您可以在类声明开头提供更多关于该类的信息，例如其父类的名称、是否实现了任何接口等。例如：\nclass MyCLass extends MySuperClass implements YourInterface &#123;\n    // field, constructor, and method declarations\n&#125;\n\n这意味着 MyClass 是 MySuperClass 的子类，并且它实现了 YourInterface 接口。你也可以在类声明的最开头添加修饰符，比如 public 或 private ——由此可见，类声明的开头行可能会变得相当复杂。修饰符 public 和 private 决定了其他类能否访问 MyClass，本节后文将对此进行讨论。关于接口和继承的章节将解释如何以及为何要在类声明中使用 extends 和 implements 关键字。目前你不必担心这些额外的复杂性。通常，类声明可以包含以下组件，顺序如下：\n\n修饰符如 public、private 以及其他若干修饰符（你将在后续内容中遇到）。（但请注意，private 修饰符仅可应用于嵌套类。）\n类名，按惯例首字母大写。\n类的父类（超类）名称（如有），前面需加上关键字 extends。一个类只能继承（子类化）一个父类。\n由关键字 implements 引导的、该类实现的接口的逗号分隔列表（如有）。一个类可以实现多个接口。\n用大括号 {} 包围的类主体。\n\n声明成员变量变量有以下几种类型：\n\n类中的成员变量——这些被称为字段。\n方法或代码块中的变量——这些称为局部变量。\n方法声明中的变量——这些被称为参数。\nBicycle 类使用以下代码行定义其字段：\n\npublic int cadence;\npublic int gear;\npublic int speed;\n\n字段声明由三个按顺序排列的组成部分构成：\n\n零个或多个修饰符，例如 public 或 private。\n字段的数据类型\n字段的名称\n\nBicycle 类的字段名为 cadence、gear 和 speed，数据类型均为整型（int）。public 关键字将这些字段标识为公共成员，任何能够访问该类的对象均可访问它们。\n控制成员的访问第一个（最左侧）修饰符用于控制其他类对成员字段的访问权限。目前只需考虑 public 和 private 两种。其他访问修饰符将在后续章节中讨论。\n\npublic  修饰符——该字段可被所有类访问。\nprivate 修饰符——该字段仅在其所属类内部可访问。\n\n遵循封装原则，通常会将字段设为私有。这意味着它们只能从 Bicycle 类内部直接访问。然而我们仍需获取这些值，可通过添加公共方法间接实现——这些方法将为我们获取字段值：\npublic class Bicycle &#123;\n    // the bicycle class has three fields\n    public int cadence;\n    public int gear;\n    public int speed;\n\n    // the Bicycle class has one constructor\n    public Bicycle(int startCadence, int startSpeed, int startGear) &#123;\n        gear = startGear;\n        cadence = startCadence;\n        speed = startSpeed;\n    &#125;\n    \n    public int getCadence() &#123;\n        return cadence;\n    &#125;\n\n    public void setCadence(int cadence) &#123;\n        this.cadence = cadence;\n    &#125;\n\n    public int getGear() &#123;\n        return gear;\n    &#125;\n\n    public void setGear(int gear) &#123;\n        this.gear = gear;\n    &#125;\n\n    public void applyBrake(int decrement) &#123;\n        speed -= decrement;\n    &#125;   \n\n    public void speedUp(int increment) &#123;\n        speed += increment;\n    &#125;\n&#125;\n\n设置变量的类型所有变量都必须具有类型。你可以使用基本类型，如 int、float、boolean 等；也可以使用引用类型，如字符串 strings、arrays 或 objects。\n命名一个变量所有变量——无论是字段、局部变量还是参数——均遵循语言基础部分“变量与命名”中所述的命名规则与约定。\n需注意本节内容：方法名与类名同样适用上述命名规则，但需满足以下例外：\n\n类名首字母应大写，\n方法名首个（或唯一）单词应为动词。\n\n","categories":["技术","Java"],"tags":["Java Programming Language"]},{"title":"对象，类 与 接口","url":"//technology/java/java-ocipi/","content":"不同于国内大多数Java教程，英文世界的Java教程首先讲的就是Java的面向对象的特性。因为Java是一门纯面向对象的编程语言，理解面向对象的概念对于学习Java至关重要。如果你从没有使用过(object-oriented programming language，OOP)面向对象编程语言，那么你需要先了解一些基本概念。  \n\n\nWhat is an Object?\nObject 是一组相关的 状态 与 行为 在软件视角上的组合。  \n\n对象分享两个特征：状态与行为。例如，一只狗有状态（名字、颜色、年龄）和行为（吠、跑、摇尾巴）。自行车也有状态（当前档位、当前速度、当前方向）和行为（换档、刹车、转向）。找到真实世界中的物体，并思考它们的状态与行为，是理解对象概念的好方法。  \n软件对象也由状态与其相关的行为组成。一个对象通过 fields（也称为属性） 来存储状态，通过 methods（也称为函数） 暴露它的行为。Methods操作一个对象的状态，并作为对象间的主要通信手段。隐藏内部状态并且仅通过methods与对象交互，是面向对象编程的一个重要原则，称为 data-encapsulation（封装），这是一个面向对象编程的基础原则。  \nWhat is a Class?考虑真实世界的自行车。一个城市有各种品牌的自行车。每一个品牌所有的自行车都有相同的零部件和形状。因此每一个自行车都是一个真实存在的东西，它属于自行车这个类别。我们把这个类别称为 Class（类）。每一个具体的自行车就是这个类的一个 Instance （实例）。\n下面的 Bicycle 类是一种可能的实现：  \npublic class Bicycle &#123;\n\n    int cadence = 0;\n    int speed = 0;\n    int gear = 1;\n\n    void changeCadence(int newValue) &#123;\n        cadence = newValue;\n    &#125;\n\n    void changeGear(int newValue) &#123;\n        gear = newValue;\n    &#125;\n\n    void speedUp(int increment) &#123;\n        speed += increment;\n    &#125;\n\n    void applyBrakes(int decrement) &#123;\n        speed -= decrement;\n    &#125;\n\n    void printStates() &#123;\n        IO.println(\"cadence: \" + cadence + \" speed: \"\n                + speed + \" gear: \" + gear);\n    &#125;\n&#125;\n字段cadence、speed和gear表示了对象的状态。同时，方法 changeCadence()、changeGear()、speedUp() 和 applyBrakes 定义了它与外部世界的交互方式。  \n你可能注意到上面的类中没有包含任何 main() 方法。这是因为类本身并不是一个完整的程序。类只是一个对象的蓝图。要运行程序，你需要创建一个包含 main() 方法的类，并在该方法中创建类的实例。下面是一个包含 main() 方法的类，它创建了两个个 Bicycle 类的实例并调用了它的方法：    \npublic class BicycleDemo &#123;\n    public static void main(String[] args) &#123;\n\n        // Create two different\n        // Bicycle objects\n        Bicycle bike1 = new Bicycle();\n        Bicycle bike2 = new Bicycle();\n\n        // Invoke methods on\n        // those objects\n        bike1.changeCadence(50);\n        bike1.speedUp(10);\n        bike1.changeGear(2);\n        bike1.printStates();\n\n        bike2.changeCadence(50);\n        bike2.speedUp(10);\n        bike2.changeGear(2);\n        bike2.changeCadence(40);\n        bike2.speedUp(10);\n        bike2.changeGear(3);\n        bike2.printStates();\n    &#125;\n&#125;\n\n\n输出如下：  \ncadence: 50 speed: 10 gear: 2\ncadence: 40 speed: 20 gear: 3\nWhat is Inheritance?不同类型的物体往往有某项共同点。山地自行车，公路自行车和双座自行车。举个例子来说，他们都共享自行车的特征（当前速度、当前踏频、当前档位）。即使他们各自也定义了属于自己的额外的特性。双座自行车有两个座位和两个车把手，公路自行车有赛车车把，一些山地自行车有额外的齿盘，给它们更多的档位。  \n面向对象编程允许类从其他类继承一些共同使用的状态和行为。在这个例子里，Bicycle类是山地车类、、公路车和双座自行车的超类（superclass）。在Java编程语言中，每个类允许有一个直接的superclass。每一个超类可能潜在地有无数个子类（subclass）。  \n创建子类的语法很简单，在类声明中使用关键字 extends。后面跟着需要继承的类名。下面是一个从Bicycle类继承的MountainBike类的例子：\npublic class MountainBike extends Bicycle &#123;\n    // new fields and methods defining\n    // a mountain bike would go here\n&#125;\n\n这种方式给了MountainBike类所有Bicycle类相同的字段和方法,却让它的代码专注于自身那些独有的特性。  \nWhat is an Interface?就像前面说的那样，对象与外部世界交互是通过它暴露给外部的方法完成的。方法构成对象与外部世界的接口。举个例子，电视机的按钮就是你和电视机内部电路之间的接口。你按下电源按钮，电视机就会打开或者关闭。最常见的形式是，接口是一组相关的方法，这些方法有空的主体。用自行车的例子来说，如果定义成一个接口，它可能看起来像这样：  \npublic interface IBicycle &#123;\n\n    //  wheel revolutions per minute\n    void changeCadence(int newValue);\n\n    void changeGear(int newValue);\n\n    void speedUp(int increment);\n\n    void applyBrakes(int decrement);\n&#125;\n\n实现此接口，你的类名字最好换一下，比如叫ACMEBicycle。同时你要在类声明时使用关键字 implements 来声明你要实现这个接口：  \npublic class ACMEBicycle implements IBicycle &#123;\n\n    int cadence = 0;\n    int speed = 0;\n    int gear = 1;\n\n    // The compiler will now require that methods\n    // changeCadence, changeGear, speedUp, and applyBrakes\n    // all be implemented. Compilation will fail if\n    // these methods are missing from this class.\n    \n    public void changeCadence(int newValue) &#123;\n        cadence = newValue;\n    &#125;\n\n    public void changeGear(int newValue) &#123;\n        gear = newValue;\n    &#125;\n\n    public void speedUp(int increment) &#123;\n        speed += increment;\n    &#125;\n\n    public void applyBrakes(int decrement) &#123;\n        speed -= decrement;\n    &#125;\n\n    void printStates() &#123;\n        IO.println(\"cadence: \" + cadence + \" speed: \"\n                + speed + \" gear: \" + gear);\n    &#125;\n&#125;\n\n实现接口使类能够更正式地承诺其将提供的行为。接口构成了类与外部世界交互的契约。与此同时，这个契约在编译时被编译器强制执行。如果你的类声称实现了某个接口，该接口定义的所有方法都必须出现在其源代码中，否则类将无法成功编译。  \nWhat is a Package?包（package） 就是一个命名空间，它由一些相关的类和接口组成。概念上思考，它有点类似电脑上的不同文件夹。你可能保存一个HTML在一个文件夹，图片在另一个文件夹。由于用Java编写的程序可能包含成百上千个类，将相关类和接口放入包中进行组织是有意义的。  \nJava平台提供了大量的类库,以便于程序的开发。这个类库被称为 Application Programming Interface (API)。其中代表了与常用编程最常关联的任务。例如：String 对象包含字符串的状态和行为。File 对象允许程序员轻松的创建、删除、检查、比较或者修改一个文件。Socket 对象允许创建和使用网络套接字。这些成千上万的类库使你能够专注于你的程序的独特功能，而不是重新发明轮子。  \n The Java Platform API Specification 包含了完整的包、接口、类、字段和方法的列表。打开你的浏览器并且收藏它，作为程序员，它将成为你最重要的参考文档。\n","categories":["技术","Java"],"tags":["Java Programming Language"]},{"title":"方法的定义","url":"//technology/java/defining-methods/","content":"定义一个方法以下是一个典型的方法声明示例：\npublic double calculateAnswer(double wingSpan, int numberOfEngines, \n                              double length, double grossTons) &#123;\n    // do the calculation here\n&#125;\n\n方法声明的必备要素仅包括方法的返回类型、名称、一对圆括号（） 以及用大括号 {} 括起的代码主体。更普遍地说，方法声明包含6个组成部分，按照顺序如下：\n\n修饰符——例如 public 、private 以及你将在后续学习到的其他修饰符。\n返回类型——方法返回值的数据类型，若方法不返回值则为 void。\n方法名称——字段名称的命名规则同样适用于方法名称，但约定稍有不同。\n括号中的参数列表——以逗号分隔的输入参数列表，参数前标注其数据类型，并用括号()括起。若无参数，则必须使用空括号。\nException列表——将在后文讨论。\n方法主体，用大括号括起来——方法的代码，包括局部变量的声明，都放在这里。修饰符、返回类型和参数将在本节后文讨论。异常将在后续章节中讨论。\n定义：方法声明的两个组成部分构成了方法签名——方法名称和参数类型。\n\n\n\n上述声明的方法的签名是：\ncalculateAnswer(double, int, double, double)\n命名一个方法尽管方法名称可以是任何合法标识符，但编码规范对方法名称有所限制。按惯例，方法名称应采用小写动词形式，或由多个单词组成且以小写动词开头，随后接形容词、名词等。在多词名称中，第二个及后续单词的首字母均应大写。以下是一些示例：\nrun\nrunFast\ngetBackground\ngetFinalData\ncompareTo\nsetX\nisEmpty\n通常，方法在其所属类中具有唯一名称。然而，由于方法重载，某个方法可能与其他方法具有相同名称。\n方法重载Java编程语言支持方法重载，且能够区分具有不同方法签名的方法。这意味着同一类中的方法即使名称相同，只要参数列表不同即可共存（此规则存在某些例外情况，将在”继承”章节中讨论）。假设你有一个类，能够使用书法绘制各种类型的数据（字符串、整数等），并且包含绘制每种数据类型的方法。为每个方法使用新名称会很繁琐——例如 drawString()、drawInteger()、drawFloat() 等。在Java编程语言中，你可以为所有绘制方法使用相同名称，但通过传递不同的参数列表来区分各方法。因此，该数据绘制类可能声明四个名为 draw() 的方法，每个方法都具有不同的参数列表。\npublic class DataArtist &#123;\n    ...\n    public void draw(String s) &#123;\n        ...\n    &#125;\n    public void draw(int i) &#123;\n        ...\n    &#125;\n    public void draw(double f) &#123;\n        ...\n    &#125;\n    public void draw(int i, double f) &#123;\n        ...\n    &#125;\n&#125;\n重载方法通过传递给方法的参数数量和类型来区分。在代码示例中，draw(String s) 和 draw(int i) 是不同的独立方法，因为它们需要不同的参数类型。你不能声明多个具有相同名称且参数数量和类型相同的方法，因为编译器无法区分它们。\n编译器在区分方法时不会考虑返回类型，因此即使两个方法的返回类型不同，你也无法声明具有相同签名的方法。\n\n注意：应谨慎使用重载方法，因为它们会大幅降低代码的可读性。\n\n","categories":["技术","Java"],"tags":["Java Programming Language"]},{"title":"操作符","url":"//technology/java/operators/","content":"Operators既然你已经学会了如何声明和初始化变量，接下来你可能想知道如何对变量进行操作。学习Java编程语言的运算符是一个很好的起点。运算符是特殊符号，它们对一个、两个或三个操作数执行特定操作，然后返回结果。\n\n在探索Java编程语言的运算符时，提前了解哪些运算符具有最高优先级会对您有所帮助。下表中的运算符按优先级顺序排列。运算符在表格中位置越靠上，其优先级越高。优先级较高的运算符将在优先级相对较低的运算符之前进行求值。同一行中的运算符具有相同优先级。当相同优先级的运算符出现在同一表达式中时，需遵循特定规则确定其计算顺序。除赋值运算符外，所有二元运算符均按从左到右的顺序计算；赋值运算符则按从右到左的顺序计算。\n\n\n\n操作符\n优先级\n\n\n\npostfix\nexpr++， expr–\n\n\nunary\n++expr， –expr， +expr， -expr， ~， !\n\n\nmultiplicative\n*， &#x2F;， %\n\n\nadditive\n+， -\n\n\nshift\n &lt;&lt;， &gt;&gt;， &gt;&gt;&gt; \n\n\nrelational\n &lt;，&gt;，&lt;&#x3D;，&gt;&#x3D;，instanceof \n\n\nequality\n &#x3D;&#x3D;， !&#x3D; \n\n\nbitwise AND\n &amp; \n\n\nbitwise exclusive OR\n ^ \n\n\nbitwise inclusive OR\n | \n\n\nlogical AND\n &amp;&amp; \n\n\nlogical OR\n || \n\n\nternary\n ? : \n\n\nassignment\n &#x3D;，+&#x3D;，-&#x3D;，*&#x3D;，&#x2F;&#x3D;，%&#x3D;，&amp;&#x3D;，^&#x3D;，|&#x3D;，&lt;&lt;&#x3D;，&gt;&gt;&#x3D;，&gt;&gt;&gt;&#x3D; \n\n\n在通用编程中，某些运算符的使用频率往往高于其他运算符；例如赋值运算符 &#x3D; 的使用远比无符号右移运算符 &gt;&gt;&gt;  更为普遍。基于此，下文将首先聚焦于日常工作中最常用的运算符，最后再探讨那些较少使用的运算符。每项讨论均附有可编译运行的示例代码，通过研究其输出结果，有助于巩固所学知识。\n简单赋值运算符你最常遇到的运算符之一就是简单的赋值运算符 &#x3D;。你在 Bicycle 类中见过这个运算符；它将右侧的值赋给左侧的操作数：\nint cadence = 0;\nint speed = 0;\nint gear = 1;\n该运算符也可用于对象以分配对象引用。\n算术运算符Java编程语言提供了执行加法、减法、乘法和除法的运算符。这些运算符很可能与你在基础数学中接触过的对应运算符相似。唯一可能看起来陌生的符号是%，它表示将一个操作数除以另一个操作数，并返回余数作为结果。\n\n\n\n操作符\n描述\n\n\n\n+\n加法运算符（也用于字符串连接）\n\n\n-\n减法运算符\n\n\n*\n乘法运算符\n\n\n&#x2F;\n除法运算符\n\n\n%\n求余运算符\n\n\n以下程序 ArithmeticDemo 用于测试算术运算符。\npublic class ArithmeticDemo &#123;\n    public static void main(String[] args) &#123;\n        int result = 1 + 2;\n        //result is now 3\n        IO.println(\"1 + 2 = \" + result);\n        int original_result = result;\n\n        result = result - 1;\n        // result is now 2\n        IO.println(original_result + \" - 1 = \" + result);\n        original_result = result;\n\n        result = result * 2;\n        // result is now 4\n        IO.println(original_result + \" * 2 = \" + result);\n        original_result = result;\n\n        result = result / 2;\n        // result is now 2\n        IO.println(original_result + \" / 2 = \" + result);\n        original_result = result;\n\n        result = result + 8;\n        // result is now 10\n        IO.println(original_result + \" + 8 = \" + result);\n        original_result = result;\n\n        result = result % 7;\n        // result is now 3\n        IO.println(original_result + \" % 7 = \" + result);\n    &#125;\n&#125;\n运行该程序将产生以下输出：\n1 + 2 = 3\n3 - 1 = 2\n2 * 2 = 4\n4 / 2 = 2\n2 + 8 = 10\n10 % 7 = 3\n\n您还可以将算术运算符与简单赋值运算符结合使用，形成复合赋值。例如，x +&#x3D; 1; 和 x &#x3D; x + 1; 都能将变量 x 的值增加 1。  \n\n运算符也可用于连接（拼接）两个字符串，如下面的ConcatDemo程序所示：\n\npublic class ConcatDemo &#123;\n    public static void main(String[] args) &#123;\n        String firstString = \"This is\";\n        String secondString = \" a concatenated string.\";\n        String thirdString = firstString + secondString;\n        IO.println(thirdString);\n    &#125;\n&#125;\n本程序执行完毕时，变量 thirdString 包含字符串 This is a concatenated string.，该字符串将被打印到标准输出。\n一元运算符一元运算符仅需一个操作数；它们执行多种操作，例如将值增减1、取表达式的负值，或反转布尔值的状态。\n\n\n\n操作符\n描述\n\n\n\n+\n一元加运算符；表示正值（不过数字本身是正的，无需此运算符）\n\n\n-\n一元减运算符；取表达式的负值\n\n\n++\n递增运算符；将值增加1\n\n\n–\n递减运算符；将值减去1\n\n\n！\n逻辑取反运算符；将布尔值取反\n\n\n以下程序 UnaryDemo 用于测试一元运算符：\n\npublic class UnaryDemo &#123;\n    public static void main(String[] args) &#123;\n        int  result = +1;\n        // result is now 1\n        IO.println(result);\n\n        result--;\n        // result is now 0\n        IO.println(result);\n\n        result++;\n        // result is now 1\n        IO.println(result);\n\n        result = -result;\n        // result is now -1\n        IO.println(result);\n\n        boolean success = false;\n        // false\n        IO.println(success);\n        // true\n        IO.println(!success);\n    &#125;\n&#125;\n增量&#x2F;减量运算符可置于操作数之前（前缀）或之后（后缀）。代码 result++; 和 ++result; 均会使 result 值增加 1。二者的唯一区别在于：前缀形式（++result）的表达式结果为递增后的值，而后缀形式（result++）的表达式结果为原始值。若仅执行简单递增&#x2F;递减操作，选择哪种形式并无实质影响。但若在更复杂的表达式中使用该运算符，选择方式可能产生显著差异。以下程序 PrePostDemo 演示了前缀&#x2F;后缀一元自增运算符：\npublic class PrePostDemo &#123;\n    public static void main(String[] args) &#123;\n        int i = 3;\n        i++;\n        // prints 4\n        IO.println(i);\n        ++i;\n        // prints 5\n        IO.println(i);\n        // prints 6\n        IO.println(++i);\n        // prints 6\n        IO.println(i++);\n        // prints 7\n        IO.println(i);\n    &#125;\n&#125;\n\n等号与关系运算符等值运算符和关系运算符用于判断一个操作数是否大于、小于、等于或不等于另一个操作数。其中大多数运算符对您来说应该也很熟悉。请注意，在比较两个基本数据类型值是否相等时，必须使用 &#x3D;&#x3D; 而非 &#x3D; 。以下程序 ComparisonDemo 用于测试比较运算符：\npublic class ComparisonDemo &#123;\n    public static void main(String[] args) &#123;\n        int value1 = 1;\n        int value2 = 2;\n        if (value1 == value2) &#123;\n            IO.println(\"value1 == value2\");\n        &#125;\n        if (value1 != value2) &#123;\n            IO.println(\"value1 != value2\");\n        &#125;\n        if (value1 > value2) &#123;\n            IO.println(\"value1 > value2\");\n        &#125;\n        if (value1 &lt; value2) &#123;\n            IO.println(\"value1 &lt; value2\");\n        &#125;\n        if (value1 &lt;= value2) &#123;\n            IO.println(\"value1 &lt;= value2\");\n        &#125;\n    &#125;\n&#125;\n运行此程序将产生以下输出：\nvalue1 != value2\nvalue1 &lt; value2\nvalue1 &lt;= value2\n\n条件运算符&amp;&amp; 和 || 运算符对两个布尔表达式执行条件与和条件或运算。这些运算符具有”短路”特性，即仅在必要时才会求值第二个操作数。\n\n\n\n运算符\n描述\n\n\n\n&amp;&amp;\n条件与运算\n\n\n||\n条件或运算\n\n\n以下程序 ConditionalDemo1 测试了这些运算符：\npublic class ConditionalDemo1 &#123;\n    public static void main(String[] args) &#123;\n        int value1 = 1;\n        int value2 = 2;\n        if ((value1 == 1) &amp;&amp; (value2 == 2)) &#123;\n            IO.println(\"value1 is 1 AND value2 is 2\");\n        &#125;\n\n        if ((value1 == 1) || (value2 == 1)) &#123;\n            IO.println(\"value1 is 1 OR value2 is 1\");\n        &#125;\n    &#125;\n&#125;\n\n另一个条件运算符是 ?:，可视为 if-then-else 语句的简写形式。该运算符因使用三个操作数而被称为三元运算符。在下例中，该运算符应解读为：”若 someCondition 为真，则将 value1 的值赋给 result；否则将 value2 的值赋给 result。”以下程序 ConditionalDemo2 测试 ?: 运算符：\npublic class ConditionalDemo2 &#123;\n    public static void main(String[] args) &#123;\n        int value1 = 1;\n        int value2 = 2;\n        int result;\n        boolean someConfition = true;\n        result = someConfition ? value1 : value2;\n\n        IO.println(result);\n    &#125;\n&#125;\n\n由于 someCondition 为真，该程序将”1”输出到屏幕。当表达式紧凑且无副作用（如赋值操作）时，使用 ?: 运算符替代 if-then-else 语句可提升代码可读性。\n类型比较运算符 instanceofinstanceof 运算符用于将对象与指定类型进行比较。你可以使用它来测试对象是否为某个类的实例、某个子类的实例，或是实现特定接口的类的实例。以下程序 InstanceofDemo 定义了一个父类（命名为 Parent ）、一个简单接口（命名为 MyInterface ）以及一个继承自父类并实现该接口的子类（命名为 Child ）。\npublic class InstanceOfDemo &#123;\n    public static void main(String[] args) &#123;\n        Parent obj1 = new Parent();\n        Parent obj2 = new Child();\n\n        IO.println(\"obj1 instanceof Parent: \" + (obj1 instanceof Parent));\n        IO.println(\"obj1 instanceof Child: \" + (obj1 instanceof Child));\n        IO.println(\"obj1 instanceof MyInterface: \" + (obj1 instanceof MyInterface));\n\n        IO.println(\"obj2 instanceof Parent: \" + (obj2 instanceof Parent));\n        IO.println(\"obj2 instanceof Child: \" + (obj2 instanceof Child));\n        IO.println(\"obj2 instanceof MyInterface: \" + (obj2 instanceof MyInterface));\n    &#125;\n&#125;\n\nclass Parent&#123;&#125;\ninterface MyInterface&#123;&#125;\nclass Child extends Parent implements MyInterface&#123;&#125;\n上面的程序将产生以下输出：\nobj1 instanceof Parent: true\nobj1 instanceof Child: false\nobj1 instanceof MyInterface: false\nobj2 instanceof Parent: true\nobj2 instanceof Child: true\nobj2 instanceof MyInterface: true\n\n使用 instanceof 运算符时，请注意 null 不是任何类型的实例。\n位运算符与位移运算符Java 编程语言还提供了对整数类型执行位运算和位移运算的运算符。本节讨论的运算符使用频率较低，因此对其介绍较为简略；其目的仅在于让您了解这些运算符的存在。\n一元位运算符~可对位模式进行反转；它可应用于任何整数类型，将所有”0”变为”1”，所有”1”变为”0”。例如，一个字节包含8位；对位模式为 00000000 的值应用此运算符后，其模式将变为 11111111 。\n带符号左移运算符 &lt;&lt; 将位模式向左移位，带符号右移运算符 &gt; 将位模式向右移位。位模式由左操作数指定，移位位数由右操作数决定。无符号右移运算符 &gt;&gt;&gt; 会在最左位移入零，而 &gt; 操作后的最左位取决于符号扩展。\n位运算符 &amp; 执行位与运算。\n位运算符 ^ 执行位异或运算。\n位运算符 | 执行位或运算。\n以下程序 BitDemo 使用位与运算符将数字 “2” 输出到标准输出。\npublic class BitDemo &#123;\n    public static void main(String[] args) &#123;\n        int bitmask = 0x000F;\n        int val = 0x2222;\n        // prints \"2\"\n        IO.println(val &amp; bitmask);\n    &#125;\n&#125;","categories":["技术","Java"],"tags":["Java Programming Language"]},{"title":"更多关于类的内容","url":"//technology/java/more-on-classes/","content":"关于类的更多内容本节将深入探讨类的相关内容，这些内容依赖于对象引用和点运算符的使用，而这些概念已在前面的对象章节中介绍过：\n\n方法的返回值。\nthis 关键字。\n类成员与实例成员的区别。\n访问控制。\n\n\n\n从方法中返回一个值当以下场景发生时，方法会返回给调用它的代码一个值：\n\n方法中的所有语句都已执行完毕\n遇到一个 return 语句\n方法抛出一个异常\n以先发生者为准\n\n在方法声明中声明方法的返回类型。在方法主体中，使用 return语句返回值。任何声明为 void 的方法都不返回值。此类方法无需包含 return 语句，但可以包含。在这种情况下，return 语句可用于跳出控制流块并退出方法，其用法如下：\nreturn;\n若尝试从声明为 void 的方法中返回值，将引发编译器错误。任何未声明为 void 的方法都必须包含一个带有对应返回值的 return 语句，如下所示：\nreturn returnValue;\n方法的返回值数据类型必须与方法声明的返回类型一致；无法从声明为返回布尔值的方法中返回整数值。在对象章节中讨论的矩形类中的 getArea() 方法返回一个整数：\n// a method for computing the area of the rectangle\npublic int getArea() &#123;\n    return width * height;\n&#125;\n此方法返回表达式 width * height 的计算结果所对应的整数值。getArea() 方法返回一个基本类型。方法也可以返回引用类型。例如，在操作 Bicycle 对象的程序中，我们可能会有如下方法：\npublic Bicycle seeWhosFastest(Bicycle myBike, Bicycle yourBike, Environment env) &#123;\n    Bicycle fastest;\n    // code to calculate which bike is \n    // faster, given each bike's gear \n    // and cadence and given the \n    // environment (terrain and wind)\n    return fastest;\n&#125;\n返回类或者接口若本节内容令您困惑，请先跳过，待完成接口与继承章节的学习后再返回此处。当方法使用类名作为返回类型时（例如 seeWhosFastest() ），返回对象的类型必须是该返回类型的子类或其本身。假设存在如下图所示的类层次结构：ImaginaryNumber 是 java.lang.Number的子类，而后者又是 Object 的子类。现在假设你声明了一个返回 Number 的方法：\npublic Number returnANumber() &#123;\n    ...\n&#125;\nreturnANumber() 方法可以返回 ImaginaryNumber 类型，但不能返回 Object 类型。ImaginaryNumber 的实例同时也是 Number 的实例，因为 ImaginaryNumber 是 Number 的子类。然而，Object 并不一定属于 Number 类型——它可能是 String 或其他类型。这种称为 covariant return type 的技术，意味着返回类型可以与子类沿相同方向发生变化。\n使用 this 关键字在实例方法或构造函数中，this 是对当前对象的引用——即正在被调用的方法或构造函数所属的对象。通过使用 this，可以在实例方法或构造函数内部访问当前对象的任何成员。\n与字段配合使用使用 this 关键字最常见的原因是某个字段被方法或构造函数参数所 shadowed。例如，Point 类是这样编写的：\npublic class Point &#123;\n    public int x = 0;\n    public int y = 0;\n        \n    //constructor\n    public Point(int a, int b) &#123;\n        x = a;\n        y = b;\n    &#125;\n&#125;\n但也可以这样写：\npublic class Point &#123;\n    public int x = 0;\n    public int y = 0;\n        \n    //constructor\n    public Point(int x, int y) &#123;\n        this.x = x;\n        this.y = y;\n    &#125;\n&#125;\n构造函数的每个参数都会覆盖对象的一个字段——在构造函数内部，x 是构造函数第一个参数的局部副本。若要引用 Point 字段 x，构造函数必须使用 this.x。\n在构造函数中使用this在构造函数内部，您也可以使用 this 关键字调用同一类中的另一个构造函数。这种调用方式称为显式构造函数调用。下面是另一个 Rectangle 类，其实现方式与“对象”部分中的不同。\npublic class Rectangle &#123;\n    private int x, y;\n    private int width, height;\n        \n    public Rectangle() &#123;\n        this(0, 0, 1, 1);\n    &#125;\n    public Rectangle(int width, int height) &#123;\n        this(0, 0, width, height);\n    &#125;\n    public Rectangle(int x, int y, int width, int height) &#123;\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    &#125;\n    ...\n&#125;\n\n该类包含一组构造函数。每个构造函数都会初始化矩形对象的部分或全部成员变量。对于未通过参数指定初始值的成员变量，构造函数会自动提供默认值。例如，无参数构造函数会在坐标(0,0)处创建一个1x1的矩形。双参数构造函数会调用四参数构造函数，传入 width 和 height 参数，但始终使用(0,0)坐标。与之前相同，编译器会根据参数数量和类型决定调用哪个构造函数。\n若存在其他构造函数调用，必须将其置于构造函数的第一行。\n控制对类成员的访问访问级别修饰符决定其他类是否可以使用特定字段或调用特定方法。访问控制分为两个级别：\n\n在最高级别—— public，或 package-private（无显式修饰符）。\n在成员级别—— public, private, protected 或 package-private（无显式修饰符）。\n\n类可以使用修饰符 public 声明，此时该类对所有类都可见。如果类没有修饰符（默认状态，也称为包私有），则仅在其所属包内可见（包是命名相关的类组——你将在后续章节中学习相关内容）。在成员级别，您也可以像最高层级一样使用 public 修饰符或不使用修饰符（包私有），且含义相同。成员还拥有两个额外的访问修饰符： private（私有）和 protected（受保护）。private 修饰符表示该成员仅能在其所属类内部访问；protected 修饰符则表示该成员不仅可在其所属包内访问（与包私有相同），还允许其他包中该类的子类访问。下表显示了每个修饰符允许的成员访问权限。\n\n\n\nModifier\nClass\nPackage\nSubclass\nWorld\n\n\n\npublic\nY\nY\nY\nY\n\n\nprotected\nY\nY\nY\nN\n\n\nno-modifier\nY\nY\nN\nN\n\n\nprivate\nY\nN\nN\nN\n\n\n第一列数据表示类本身是否具有访问由访问级别定义的成员的权限。如您所见，类始终可以访问其自身的成员。第二列指示与该类位于同一包中的类（无论其父类关系）是否可访问该成员。第三列指示该类在该包外部声明的子类是否能够访问该成员。第四列表示所有类是否都能访问该成员。\n访问权限以两种方式影响你。首先，当你使用来自其他来源的类时（例如Java平台中的类），访问权限决定了你的类可以使用这些类的哪些成员。其次，当你编写一个类时，需要为类中的每个成员变量和方法确定应具有的访问权限级别。\n访问级别的设置建议如果其他程序员使用你的类，你需要确保不会因误用而引发错误。访问权限级别能帮助你实现这一点。为特定成员设置最合理的访问权限级别。除非有充分理由，否则请使用私有权限。除常量外，应避免使用 public 字段。教程中的许多示例都使用了 public 字段。虽然这有助于简洁地说明某些要点，但不建议在生产代码中采用。这是因为 public 字段往往会将您与特定实现绑定，限制您修改代码的灵活性，因此并非良好实践。\n理解类成员在本节中，我们将探讨如何使用static关键字来创建属于类本身而非类实例的字段和方法。\n类变量当多个对象从同一类蓝图创建时，它们各自拥有独立的实例变量副本。以 Bicycle 类为例，其实例变量包括 candence、gear 和 speed 。每个 Bicycle 对象都为这些变量存储着各自的值，且这些值保存在不同的内存位置。有时，你需要创建适用于所有对象的公共变量。这可以通过 static 修饰符实现。声明中带有 static 修饰符的字段称为 static 字段或类变量。它们与类相关联，而非与任何对象相关联。该类的每个实例共享一个类变量，该变量位于内存中的固定位置。任何对象均可修改类变量的值，但操作类变量时无需创建该类的实例。例如，假设你想创建多个 Bicycle 对象，并为每个对象分配一个序列号，第一个对象从1开始。这个 ID 号对每个对象都是唯一的，因此属于实例变量。同时，你需要一个字段来记录已创建的 Bicycle 对象数量，以便知道下一个对象应分配哪个 ID 。这样的字段与任何单个对象无关，而是与整个类相关。为此需要定义类变量 numberOfBicycles，如下所示：\npublic class Bicycle &#123;\n        \n    private int cadence;\n    private int gear;\n    private int speed;\n        \n    // add an instance variable for the object ID\n    private int id;\n    \n    // add a class variable for the\n    // number of Bicycle objects instantiated\n    private static int numberOfBicycles = 0;\n        ...\n&#125;\n类变量通过类名本身进行引用，例如：\nBicycle.numberOfBicycles\n这表明它们是类变量。\n\n注意：您也可以使用对象引用（如 myBike.numberOfBicycles ）来引用静态字段，但这种做法不推荐，因为它无法明确表明这些是类变量。\n\n你可以使用 Bicycle 构造函数来设置 ID 实例变量并递增 numberOfBicycles 类变量：\npublic class Bicycle &#123;\n        \n    private int cadence;\n    private int gear;\n    private int speed;\n    private int id;\n    private static int numberOfBicycles = 0;\n        \n    public Bicycle(int startCadence, int startSpeed, int startGear)&#123;\n        gear = startGear;\n        cadence = startCadence;\n        speed = startSpeed;\n\n        // increment number of Bicycles\n        // and assign ID number\n        id = ++numberOfBicycles;\n    &#125;\n\n    // new method to return the ID instance variable\n    public int getID() &#123;\n        return id;\n    &#125;\n        ...\n&#125;\n类方法Java 编程语言支持静态方法和静态变量。静态方法在声明中带有 static 修饰符，应通过类名调用，无需创建该类的实例，例如：\nClassName.methodName(args)\n\n注意：您也可以通过对象引用（如 instanceName.methodName(args)）来调用静态方法，但这种做法不推荐，因为它无法明确表明这些方法属于类方法。\n\n静态方法的常见用途是访问静态字段。例如，我们可以在 Bicycle 类中添加一个静态方法来访问 numberOfBicycles 静态字段：\npublic static int getNumberOfBicycles() &#123;\n    return numberOfBicycles;\n&#125;\n并非所有实例变量、类变量与方法的组合都是允许的：\n\n实例方法可以直接访问实例变量和实例方法。\n实例方法可以直接访问类变量和类方法。\n类方法可以直接访问类变量和类方法。\n类方法无法直接访问实例变量或实例方法——它们必须通过对象引用实现。此外，类方法无法使用 this 关键字，因为此时不存在实例供其引用。\n\n常量static 修饰符与 final 修饰符结合使用时，也可用于定义常量。final 修饰符表明该字段的值不可更改。例如，以下变量声明定义了一个名为 PI 的常量，其值是圆周率（圆的周长与直径之比）的近似值：\nstatic final double PI = 3.141592653589793;\n以这种方式定义的常量不可重新赋值，若程序尝试如此操作，将引发编译时错误。按惯例，常量值的名称采用全大写字母书写。若名称由多个单词组成，则各单词间以下划线（_）分隔。\n\n注意：若将基本类型或字符串定义为常量且其值在编译时已知，编译器会将代码中所有常量名称替换为其值。此类常量称为编译时常量。若外部环境中常量的值发生变化（例如法定圆周率π实际应为3.975），则需重新编译所有使用该常量的类以获取最新值。\n\nBicycle 类经过本节的所有修改后，Bicycle 类现在长这样：\npublic class NewBicycle &#123;\n    private int cadence;\n    private int gear;\n    private int speed;\n    private int id;\n\n    private static int numberOfBicycles = 0;\n\n    public NewBicycle(int startCadence, int startSpeed, int startGear) &#123;\n        gear = startGear;\n        cadence = startCadence;\n        speed = startSpeed;\n        id = ++numberOfBicycles;\n    &#125;\n\n    public int getCadence() &#123;\n        return cadence;\n    &#125;\n\n    public int getGear() &#123;\n        return gear;\n    &#125;\n\n    public int getSpeed() &#123;\n        return speed;\n    &#125;\n\n    public int getId() &#123;\n        return id;\n    &#125;\n\n    public static int getNumberOfBicycles() &#123;\n        return numberOfBicycles;\n    &#125;\n\n    public void setCadence(int cadence) &#123;\n        this.cadence = cadence;\n    &#125;\n\n    public void setGear(int gear) &#123;\n        this.gear = gear;\n    &#125;\n\n    public void applyBrake(int decrement) &#123;\n        speed -= decrement;\n    &#125;\n\n    public void speedUp(int increment) &#123;\n        speed += increment;\n    &#125;\n&#125;\n\n初始化字段正如你所见，你通常可以在字段声明中为其提供初始值：\npublic class BedAndBreakfast &#123;\n\n    // initialize to 10\n    public static int capacity = 10;\n\n    // initialize to false\n    private boolean full = false;\n&#125;\n当初始化值可用且初始化操作可写在一行时，这种方式效果良好。然而，由于其简单性，这种初始化形式存在局限性。若初始化需要某些逻辑操作（例如错误处理或使用for循环填充复杂数组），简单的赋值操作便显得力不从心。实例变量可在构造函数中初始化，此时可处理错误或其他逻辑。为使类变量具备同等能力，Java编程语言引入了静态初始化块。\n\n注意:在类定义的开头声明字段并非必要，尽管这是最常见的做法。只需确保在使用字段之前完成声明和初始化即可。\n\n静态初始化块静态初始化块是一个用大括号 { } 包围的普通代码块，其前面带有 static 关键字。以下是一个示例：\nstatic &#123;\n    // whatever code is needed for initialization goes here\n&#125;\n一个类可以包含任意数量的静态初始化块，这些块可以出现在类主体的任意位置。运行时系统保证静态初始化块按其在源代码中的出现顺序被调用。静态代码块还有另一种替代方案——你可以编写私有静态方法：\nclass Whatever &#123;\n    public static varType myVar = initializeClassVariable();\n        \n    private static varType initializeClassVariable() &#123;\n\n        // initialization code goes here\n    &#125;\n&#125;\n私有静态方法的优势在于，若需重新初始化类变量，它们可供后续复用。\n请注意，您无法重新定义静态代码块的内容。一旦写入，就无法阻止该代码块的执行。如果静态代码块的内容因任何原因无法执行，则应用程序将无法正常工作，因为您将无法为该类实例化任何对象。当静态代码块包含访问外部资源（如文件系统或网络）的代码时，可能会发生这种情况。\n初始化实例成员通常，您会在构造函数中放置初始化实例变量的代码。除了使用构造函数初始化实例变量外，还有两种替代方案：initializer blocks 和 final 方法。实例变量的初始化器块与静态初始化器块完全相同，只是省略了static关键字：\n&#123;\n    // whatever code is needed for initialization goes here\n&#125;\n\nJava编译器会将初始化器代码块复制到每个构造函数中。因此，这种方法可用于在多个构造函数间共享一段代码。\nfinal 修饰的方法不能在子类中被重写。这将在继承章节中进行讨论。以下是一个使用最终方法初始化实例变量的示例：\nclass Whatever &#123;\n    private varType myVar = initializeInstanceVariable();\n        \n    protected final varType initializeInstanceVariable() &#123;\n\n        // initialization code goes here\n    &#125;\n&#125;\n这在子类可能需要重用初始化方法时尤其有用。该方法被声明为final，因为在实例初始化过程中调用非final方法可能会引发问题。\n创建和使用类与对象的总结类声明用于命名类，并将类主体用大括号括起。类名前可添加修饰符。类主体包含该类的字段、方法和构造函数。类通过字段存储状态信息，通过方法实现行为。用于初始化类新实例的构造函数采用类名命名，其形式类似于无返回类型的方法。\n类及其成员的访问权限控制方式相同：通过在声明中使用访问修饰符（如public）来实现。\n通过在成员声明中使用 static 关键字，可以指定类变量或类方法。未声明为 static 的成员默认为实例成员。类变量由该类的全部实例共享，既可通过类名访问，也可通过实例引用访问。类实例各自拥有实例变量的独立副本，必须通过实例引用进行访问。\n通过使用 new 运算符和构造函数，可以从类创建对象。new 运算符返回对所创建对象的引用。该引用可赋值给变量或直接使用。\n对于声明所在类外部代码可访问的实例变量和方法，可通过限定名进行引用。实例变量的限定名格式如下：\nobjectReference.variableName\n方法的限定名称如下所示：\nobjectReference.methodName(argumentList)\n或者\nobjectReference.methodName()\n垃圾回收器会自动清理未使用的对象。当程序中不再存在指向某个对象的引用时，该对象即被视为未使用。您可以通过将持有引用的变量设置为 null 来显式释放引用。\n","categories":["技术","Java"],"tags":["Java Programming Language"]},{"title":"嵌套类","url":"//technology/java/nested-classes/","content":"Java 编程语言允许你在另一个类内部定义类。此类称为嵌套类，示例如下：\nclass OuterClass &#123;\n    ...\n    class NestedClass &#123;\n        ...\n    &#125;\n&#125;\n\n术语：嵌套类分为两类：非静态类和静态类。非静态嵌套类称为内部类。声明为静态的嵌套类称为静态嵌套类。\n\n\nclass OuterClass &#123;\n    ...\n    class InnerClass &#123;\n        ...\n    &#125;\n    static class StaticNestedClass &#123;\n        ...\n    &#125;\n&#125;\n嵌套类是其外围类的成员。非静态嵌套类（内部类）可以访问外部类的其他成员，即使这些成员声明为私有。静态嵌套类则无法访问外部类的其他成员。作为外部类的成员，嵌套类可以声明为 private, public, protected 或 package private 。需注意外部类只能声明为 public 或 package private 。\n为什么要使用嵌套类？使用嵌套类的充分理由包括以下几点：\n\n这是一种将仅在单一位置使用的类进行逻辑分组的方法：若某个类仅对另一个类有用，则将其嵌入该类并保持二者关联是合理的。通过嵌套此类”辅助类”，可使相关包结构更为精简。\n它增强了封装性：考虑两个顶级类A和B，其中B需要访问A的成员，而这些成员原本会被声明为私有。通过将类B隐藏在类A内部，A的成员可以声明为私有，而B仍能访问它们。此外，B本身也可以对外部世界隐藏。\n这能使代码更易于阅读和维护：将小型类嵌套在顶级类中，使代码更接近其使用位置。\n\n内部类与实例方法和变量类似，内部类与其外围类的实例相关联，可直接访问该对象的方法和字段。此外，由于内部类与实例相关联，它本身无法定义任何静态成员。内部类的实例对象存在于外部类的实例中。请考虑以下类：\nclass OuterClass &#123;\n    ...\n    class InnerClass &#123;\n        ...\n    &#125;\n&#125;\n内部类的实例只能存在于外部类的实例内部，并能直接访问其包含实例的方法和字段。要实例化一个内部类，必须先实例化其外部类。然后，使用以下语法在外部对象内部创建内部对象：\nOuterClass outerObject = new OuterClass();\nOuterClass.InnerClass innerObject = outerObject.new InnerClass();\n内部类有两种特殊类型：局部类和匿名类。\n静态嵌套类与类方法和变量类似，静态嵌套类与其外部类相关联。同样地，静态嵌套类无法直接引用其外部类中定义的实例变量或方法：它只能通过对象引用来使用这些成员。内部类与嵌套静态类的示例对此进行了说明。\n\n注意：静态嵌套类与外部类（及其他类）的实例成员交互的方式，与任何其他顶级类完全相同。实际上，静态嵌套类在行为上就是一个顶级类，为了封装便利而嵌套在另一个顶级类中。《内部类与嵌套静态类示例》也展示了这一点。\n\n静态嵌套类的实例化方式与顶级类相同：\nStaticNestedClass staticNestedObject = new StaticNestedClass();\n\n内部类和嵌套静态类示例以下示例通过 OuterClass 与 TopLevelClass 演示了内部类（InnerClass）、嵌套静态类（StaticNestedClass）和顶级类（TopLevelClass）能够访问 OuterClass 的哪些类成员：\nOuterClass.javapublic class OuterClass &#123;\n    String outerField = \"Outer field\";\n    static String staticOuterField = \"Static outer field\";\n\n    //内部类和外部类的实例相同，可以访问外部类的所有成员\n    class InnerClass &#123;\n        void accessMembers() &#123;\n            IO.print(outerField);\n            IO.println(staticOuterField);\n        &#125;\n    &#125;\n\n    // 静态嵌套类，不能直接访问外部类的非静态成员\n    static class StaticNestedClass &#123;\n        void accessMembers(OuterClass outer) &#123;\n            // 编译错误，无法直接访问外部类的非静态成员\n            //IO.println(outerField);\n            IO.println(outer.outerField);\n            IO.println(staticOuterField);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        IO.println(\"Inner class:\");\n        IO.println(\"------------\");\n        OuterClass outerObject = new OuterClass();\n        OuterClass.InnerClass innerObject = outerObject.new InnerClass();\n        innerObject.accessMembers();\n\n        IO.println(\"\\nStatic nested class:\");\n        IO.println(\"----------------------\");\n        StaticNestedClass staticNestedObject = new StaticNestedClass();\n        staticNestedObject.accessMembers(outerObject);\n\n        IO.println(\"\\nTop-level class:\");\n        IO.println(\"------------------\");\n\n        TopLevelClass topLevelClass = new TopLevelClass();\n        topLevelClass.accessMembers(outerObject);\n    &#125;\n&#125;\n\nTopLevelClass.javapublic class TopLevelClass &#123;\n    void accessMembers(OuterClass outer) &#123;\n        IO.println(outer.outerField);\n        IO.println(OuterClass.staticOuterField);\n    &#125;\n&#125;\n\n这个例子打印如下：\nInner class:\n------------\nOuter field\nStatic outer field\n\nStatic nested class:\n----------------------\nOuter field\nStatic outer field\n\nTop-level class:\n------------------\nOuter field\nStatic outer field\n请注意，静态嵌套类与外部类的实例成员交互的方式与任何其他顶级类相同。静态嵌套类 StaticNestedClass 无法直接访问 outerField，因为它是外部类 OuterClass 的实例变量。Java 编译器会在高亮语句处生成错误：\nstatic class StaticNestedClass &#123;\n    void accessMembers(OuterClass outer) &#123;\n       // Compiler error: Cannot make a static reference to the non-static\n       //     field outerField\n       IO.println(outerField);\n    &#125;\n&#125;\n要修复此错误，请通过对象引用访问 outerField：\nIO.println(outer.outerField);\n同样地，顶级类 TopLevelClass 也无法直接访问 outerField。\nShadowing(覆盖？)Shadowing 翻译成什么比较合适？变量遮蔽？变量屏蔽？若某类型声明（如成员变量或参数名）在特定作用域（如内部类或方法定义）中与外部作用域的声明同名，则该声明将遮蔽外部作用域的声明。仅凭名称无法直接引用被遮蔽的声明。以下示例 ShadowTest 演示了此特性：\npublic class ShadowTest &#123;\n    public int x = 0;\n\n    class FirstLevel &#123;\n        public int x = 1;\n        void methodInFirstLevel(int x) &#123;\n            IO.println(\"x = \" + x);\n            IO.println(\"this.x = \" + this.x);\n            IO.println(\"ShadowTest.this.x = \" + ShadowTest.this.x);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        ShadowTest st = new ShadowTest();\n        ShadowTest.FirstLevel fl = st.new FirstLevel();\n        fl.methodInFirstLevel(23);\n    &#125;\n&#125;\n程序输出如下：\nx = 23\nthis.x = 1\nShadowTest.this.x = 0\n此示例定义了三个名为 x 的变量：ShadowTest 类的成员变量、内部类 FirstLevel 的成员变量，以及 methodInFirstLevel() 方法中的参数。作为 methodInFirstLevel() 方法参数定义的变量 x 会遮蔽内部类 FirstLevel 中的变量。因此，在 methodInFirstLevel() 方法中使用变量 x 时，它将指向方法参数。若要引用内部类 FirstLevel 的成员变量，需使用 this 关键字表示外部作用域：\nIO.println(\"this.x = \" + this.x);\n访问包含更大作用域的成员变量时，需通过其所属的类名进行引用。例如，以下语句从方法 methodInFirstLevel() 中访问类 ShadowTest 的成员变量：\nIO.println(\"ShadowTest.this.x = \" + ShadowTest.this.x);\n序列化强烈不建议序列化内部类，包括局部类和匿名类。当Java编译器编译某些构造（如内部类）时，会生成合成构造；这些构造包括类、方法、字段及其他在源代码中没有对应构造的元素。合成构造使Java编译器能够在不修改JVM的情况下实现新的Java语言特性。然而，不同Java编译器实现的合成结构可能存在差异，这意味着.class文件在不同实现中也可能不同。因此，若将内部类序列化后再用其他JRE实现反序列化，可能会引发兼容性问题。\n内部类的例子要了解内部类的用法，首先考虑数组。在下面的示例中，你创建一个数组，用整数值填充它，然后按升序输出数组中偶数索引的值。以下示例 DataStructure.java 包含：\n\nDataStructure 外层类包含一个构造函数，用于创建一个包含连续整数值数组（0、1、2、3 等）的 DataStructure 实例，以及一个打印数组中偶数索引值元素的方法。\nEvenIterator 内部类实现了 DataStructureIterator 接口，该接口继承自 Iterator 接口。迭代器用于遍历数据结构，通常包含用于检测最后一个元素、获取当前元素以及移至下一个元素的方法。\n一个主要方法，该方法实例化一个 DataStructure 对象（ds），然后调用 printEven() 方法来打印数组 arrayOfInts 中具有偶数索引值的元素。\n\npublic class DataStructure &#123;\n\n    // Create an array\n    private final static int SIZE = 15;\n    private int[] arrayOfInts = new int[SIZE];\n\n    public DataStructure() &#123;\n        // Fill the array with ascending integer values\n        for (int i = 0; i &lt; SIZE; i++) &#123;\n            arrayOfInts[i] = i;\n        &#125;\n    &#125;\n\n    public void printEven() &#123;\n        // Print out values of even indices of the array\n        DataStructureIterator iterator = this.new EvenIterator();\n        while (iterator.hasNext()) &#123;\n            IO.print(iterator.next() + \" \");\n        &#125;\n        IO.println();\n    &#125;\n\n    interface DataStructureIterator extends java.util.Iterator&lt;Integer> &#123;&#125;\n\n    public class EvenIterator implements DataStructureIterator &#123;\n\n        // Start stepping through the array from the beginning\n        private int nextIndex = 0;\n\n        @Override\n        public boolean hasNext() &#123;\n            // Check if the current element is the last in the array\n            return (nextIndex &lt;= SIZE - 1);\n        &#125;\n\n        @Override\n        public Integer next() &#123;\n            // Record a value of an even index of the array\n            Integer retValue = arrayOfInts[nextIndex];\n\n            // Get the next even element\n            nextIndex += 2;\n            return retValue;\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n\n        // Fill the array with integer values and print out only values of even indices\n        DataStructure ds = new DataStructure();\n        ds.printEven();\n    &#125;\n&#125;\n输出如下：\n0 2 4 6 8 10 12 14\n请注意，EvenIterator 类直接引用了 DataStructure 对象的 arrayOfInts 实例变量。你可以使用内部类来实现辅助类，例如本示例中所示的类。要处理用户界面事件，你必须掌握内部类的使用方法，因为事件处理机制大量依赖于它们。\n局部和匿名类还有两种额外的内部类类型。你可以在方法体内声明内部类，这类类称为局部类。你也可以在方法体内声明不命名类名的内部类，这类类称为匿名类。\n修饰符对于内部类，你可以使用与外部类其他成员相同的修饰符。例如，你可以使用访问限定符 private、public 和 protected 来限制对内部类的访问，就像你使用它们来限制对其他类成员的访问一样。\nLocal Classes(局部类)局部类是在代码块中定义的类，代码块是指由大括号括起的零个或多个语句组成的集合。通常在方法主体中会定义局部类。\n本节涵盖以下主题：\n\n局部类的定义\n访问外围类的成员\n局部类的屏蔽\n局部类与内部类的相似之处\n\n声明一个局部类您可以在任何代码块内定义局部类（更多信息请参阅表达式、语句和代码块）。例如，您可以在方法主体、for循环或if子句中定义局部类。以下示例 LocalClassExample 用于验证两个电话号码。它在 validatePhoneNumber() 方法中定义了本地类 PhoneNumber：\npublic class LocalClassDemo &#123;\n\n    static String regularExpression = \"[^0-9]\";\n\n    public static void validatePhoneNumber(String phoneNumber1, String phoneNumber2) &#123;\n        final int numberLength = 10;\n\n        class PhoneNumber &#123;\n\n            String formattedPhoneNumber = null;\n\n            PhoneNumber(String phoneNumber) &#123;\n                // numberLength = 7;\n                String currentNumber = phoneNumber.replaceAll(\n                        regularExpression, \"\");\n                if (currentNumber.length() == numberLength) &#123;\n                    formattedPhoneNumber = currentNumber;\n                &#125; else &#123;\n                    formattedPhoneNumber = null;\n                &#125;\n            &#125;\n\n            public String getNumber() &#123;\n                return formattedPhoneNumber;\n            &#125;\n        &#125;\n\n        PhoneNumber myNumber1 = new PhoneNumber(phoneNumber1);\n        PhoneNumber myNumber2 = new PhoneNumber(phoneNumber2);\n\n        if (myNumber1.getNumber() == null) &#123;\n            IO.println(\"First number is invalid\");\n        &#125; else &#123;\n            IO.println(\"First number is \" + myNumber1.getNumber());\n        &#125;\n        if (myNumber2.getNumber() == null) &#123;\n            IO.println(\"Second number is invalid\");\n        &#125; else &#123;\n            IO.println(\"Second number is \" + myNumber2.getNumber());\n        &#125;\n    &#125;\n\n    public static void main(String... args) &#123;\n        validatePhoneNumber(\"123-456-7890\", \"456-7890\");\n    &#125;\n&#125;\n该示例通过以下步骤验证电话号码：首先移除电话号码中除0至9数字外的所有字符，随后检查电话号码是否恰好包含十位数字（北美电话号码的长度）。该示例输出如下内容：\nFirst number is 1234567890\nSecond number is invalid\n访问外围类的成员局部类可以访问其外围类的成员。在上例中，PhoneNumber() 构造函数访问了成员 LocalClassExample.regularExpression 。此外，局部类可以访问局部变量。但局部类仅能访问声明为 final 的局部变量。当局部类访问其外围代码块的局部变量或参数时，会捕获该变量或参数。例如，PhoneNumber() 构造函数能访问局部变量 numberLength，因为该变量声明为 final； numberLength 即为被捕获的变量。\n然而，从 Java SE 8 开始，局部类可以访问其外围代码块中具有 final 或实质上 final 属性的局部变量和参数。初始化后值永不改变的变量或参数即具有实质上 final 的属性。例如，假设变量 numberLength 未声明为 final，若在 PhoneNumber() 构造函数中添加高亮显示的赋值语句，将有效电话号码的长度改为 7 位：\nPhoneNumber(String phoneNumber) &#123;\n    numberLength = 7;\n    String currentNumber = phoneNumber.replaceAll(\n        regularExpression, \"\");\n    if (currentNumber.length() == numberLength)\n        formattedPhoneNumber = currentNumber;\n    else\n        formattedPhoneNumber = null;\n&#125;\n由于这个赋值语句，变量 numberLength 实际上不再是 final 类型。因此，当内部类 PhoneNumber 尝试访问 numberLength 变量时，Java 编译器会生成类似于“从内部类引用的局部变量必须是 final 或实际上是 final”的错误信息：\nif (currentNumber.length() == numberLength)\n从 Java SE 8 开始，若在方法中声明局部类，该局部类即可访问方法的参数。例如，您可以在 PhoneNumber 局部类中定义以下方法：\npublic void printOriginalNumbers() &#123;\n    IO.println(\"Original numbers are \" + phoneNumber1 +\n        \" and \" + phoneNumber2);\n&#125;\n方法 printOriginalNumbers() 访问了方法 validatePhoneNumber() 的参数 phoneNumber1 和 phoneNumber2。\n局部类中声明的类型（如变量）会遮蔽外部作用域中同名的声明。更多信息请参阅遮蔽机制。\n局部类与内部类的相似之处局部类与内部类类似，因为它们无法定义或声明任何静态成员。在静态方法中定义的局部类（例如在 validatePhoneNumber() 静态方法中定义的 PhoneNumber 类）只能引用其外围类的静态成员。例如，若未将成员变量 regularExpression 声明为静态，Java 编译器将报错，提示类似于“非静态变量 regularExpression 无法从静态上下文中引用”。局部类是非静态的，因为它们能够访问包含它们的代码块的实例成员。因此，它们不能包含大多数类型的静态声明。你不能在代码块内部声明接口；接口本质上是静态的。例如，以下代码片段无法编译，因为接口 HelloThere 被定义在方法 greetInEnglish() 的主体内部：\npublic void greetInEnglish() &#123;\n    interface HelloThere &#123;\n       public void greet();\n    &#125;\n    class EnglishHelloThere implements HelloThere &#123;\n        public void greet() &#123;\n            IO.println(\"Hello \" + name);\n        &#125;\n    &#125;\n    HelloThere myGreeting = new EnglishHelloThere();\n    myGreeting.greet();\n&#125;\n在局部类中不能声明静态初始化器或成员接口。以下代码片段无法编译，因为方法 EnglishGoodbye.sayGoodbye() 被声明为静态。当编译器遇到该方法定义时，会生成类似于”修饰符 static 仅允许用于常量变量声明”的错误：\n本地类可以包含静态成员，前提是这些成员必须是常量变量。（常量变量是指声明为 final 并使用编译时常量表达式初始化的基本类型或 String 类型的变量。编译时常量表达式通常是字符串或可在编译时求值的算术表达式。更多信息请参阅《理解类成员》。）以下代码片段能够编译，因为静态成员 EnglishGoodbye.farewell 是常量变量：\npublic void sayGoodbyeInEnglish() &#123;\n    class EnglishGoodbye &#123;\n        public static final String farewell = \"Bye bye\";\n        public void sayGoodbye() &#123;\n            IO.println(farewell);\n        &#125;\n    &#125;\n    EnglishGoodbye myEnglishGoodbye = new EnglishGoodbye();\n    myEnglishGoodbye.sayGoodbye();\n&#125;\n局部类的使用频率远低于静态内部类和匿名内部类。\n匿名类匿名类能让你的代码更简洁。它们允许你在声明类的同时直接实例化该类。它们类似于局部类，但没有名称。当你需要仅使用局部类一次时，可以采用这种方式。\n声明匿名类局部类是类声明，而匿名类则是表达式，这意味着你需要在另一个表达式中定义该类。以下示例 HelloWorldAnonymousClasses 在局部变量 frenchGreeting 和 spanishGreeting 的初始化语句中使用了匿名类，但变量 englishGreeting 的初始化则使用了局部类：\npublic class HelloWorldAnonymousClasses &#123;\n\n    interface HelloWorld &#123;\n\n        public void greet();\n\n        public void greetSomeone(String someone);\n    &#125;\n\n    public void sayHello() &#123;\n\n        class EnglishGreeting implements HelloWorld &#123;\n\n            String name = \"world\";\n\n            public void greet() &#123;\n                greetSomeone(\"world\");\n            &#125;\n\n            public void greetSomeone(String someone) &#123;\n                name = someone;\n                IO.println(\"Hello \" + name);\n            &#125;\n        &#125;\n\n        HelloWorld englishGreeting = new EnglishGreeting();\n        HelloWorld frenchGreeting = new HelloWorld() &#123;\n            String name = \"tout le monde\";\n\n            public void greet() &#123;\n                greetSomeone(\"tout le monde\");\n            &#125;\n\n            public void greetSomeone(String someone) &#123;\n                name = someone;\n                IO.println(\"Salut \" + name);\n            &#125;\n        &#125;;\n        HelloWorld spanishGreeting = new HelloWorld() &#123;\n            String name = \"mundo\";\n\n            public void greet() &#123;\n                greetSomeone(\"mundo\");\n            &#125;\n\n            public void greetSomeone(String someone) &#123;\n                name = someone;\n                IO.println(\"Hola \" + name);\n            &#125;\n        &#125;;\n\n        englishGreeting.greet();\n        frenchGreeting.greetSomeone(\"Fred\");\n        spanishGreeting.greet();\n    &#125;\n\n    public static void main(String[] args) &#123;\n        HelloWorldAnonymousClasses myApp = new HelloWorldAnonymousClasses();\n        myApp.sayHello();\n    &#125;\n&#125;\n如前所述，匿名类是一种表达式。匿名类表达式的语法类似于构造函数的调用，区别在于其中包含一段代码块定义的类。考虑 frenchGreeting 对象的实例化过程：\nHelloWorld frenchGreeting = new HelloWorld() &#123;\n    String name = \"tout le monde\";\n    public void greet() &#123;\n        greetSomeone(\"tout le monde\");\n    &#125;\n    public void greetSomeone(String someone) &#123;\n        name = someone;\n        IO.println(\"Salut \" + name);\n    &#125;\n&#125;;\n匿名类表达式由以下部分组成：\n\nnew 操作符\n要实现的接口名称或要扩展的类名称。在此示例中，匿名类实现了接口 HelloWorld 。\n括号中包含构造函数的参数，就像普通的类实例创建表达式一样。注意：当你实现接口时，没有构造函数，因此使用一对空括号，如本例所示。\n主体，即类声明主体。更具体地说，在主体中允许方法声明，但不允许语句。\n由于匿名类定义是一个表达式，它必须作为语句的一部分存在。在此示例中，匿名类表达式是实例化 frenchGreeting 对象的语句组成部分。（这解释了为何闭合大括号后需要分号。）\n\n访问外围作用域的局部变量，以及声明和访问匿名类的成员与局部类类似，匿名类可以捕获变量；它们对包含作用域的局部变量具有相同的访问权限：\n\n匿名类可以访问其外围类的成员。\n匿名类无法访问其外围作用域中未声明为final或实质上为final的局部变量。\n与嵌套类类似，在匿名类中声明的类型（如变量）会遮蔽外部作用域中所有同名声明。更多信息请参阅遮蔽机制。\n\n匿名类在其成员方面也与局部类具有相同的限制：\n\n在匿名类中不能声明静态初始化器或成员接口。\n匿名类可以包含静态成员，前提是这些成员必须是常量变量。\n\n请注意，您可以在匿名类中声明以下内容：\n\n字段\n额外方法（即使它们未实现任何超类的成员方法）\n实例初始化器\n局部类\n\n然而，你无法在匿名类中声明构造函数。\n","categories":["技术","Java"],"tags":["Java Programming Language"]},{"title":"Java 知识体系梳理汇总","url":"//technology/java/java/","content":"写这些文章的初衷是什么？中文世界的Java教材亦或者视频教程使用的JDK版本大多比较滞后，且带有传统编程思维的局限性(从面向过程到面向对象的转变)。内容编排和知识体系也比较陈旧，无法和英文世界的Java知识体系接轨。因此我决定梳理自己的Java知识体系，分享给大家。Java语言的内容翻译自 dev.java，内容非常棒。\n主要针对哪些问题？\n碎片化的Java知识体系\n过时的Java编程思维\n\n\n\n都涉及哪些内容？结合自己在Discord、Quora和Reddit等社区的交流经验，梳理出一套涵盖Java基础、进阶和高级的知识体系，内容包括但不限于：\n\nJava基础语法和核心概念\n面向对象编程（OOP）原理\nJava集合框架\n异常处理机制\n多线程和并发编程\nJava I&#x2F;O和NIO\nJava 8及以上版本的新特性（如Lambda表达式、Stream API等）\nJVM原理和性能优化\n常用Java开发工具和框架（如Maven、Gradle、Spring等）\n实践项目和代码示例\n\n文章列表Java 入门\n对象、类、接口、继承和包\n\nJava 基础\n变量与命名\n基础数据类型\n数组\nVar关键字\n操作符\n表达式、语句和代码块\n控制流语句\nSwitch 语句\nSwitch 表达式\n\nJava 面向对象编程\n创建Class\n方法的定义\n构造函数\n调用方法和构造函数\n创建和使用对象\n更多关于类的内容\n嵌套类\n枚举类型\n何时使用嵌套类，局部类，匿名类和Lambda表达式\n使用Record建模不可变数据\n数字和字符串\n数值\n字符\n字符串\nString Builders\nBoxing and Unboxing in Java\n\n\n\n","categories":["技术","Java"],"tags":["Java Programming Language"]},{"title":"数值","url":"//technology/java/numbers/","content":"数值本节首先讨论 java.lang 包中的 Number 类及其子类，并说明在哪些情况下应使用这些类的实例化而非基本数值类型。\n本节还介绍了 PrintStream 和 DecimalFormat 类，它们提供了用于写入格式化数值输出的方法。\n\n最后，我们讨论了java.lang 包中的 Math 类。该类包含数学函数，用于补充语言内置的运算符功能。此类提供了三角函数、指数函数等相关方法。\n在处理数字时，大多数情况下你会在代码中使用基本类型。例如：\nint i = 500;\nfloat gpa = 3.65f;\nbyte mask = 0x7f;\n然而，使用对象替代基本数据类型是有其理由的，Java平台为每种基本数据类型都提供了包装类。这些类将基本数据类型”包装”成对象。通常，包装操作由编译器完成——当你在需要对象的位置使用基本数据类型时，编译器会自动将该类型装箱到对应的包装类中。同样地，当需要基本数据类型时使用数字对象，编译器会自动为你解除包装。更多信息请参阅”自动装箱与拆箱”章节。\n所有数字包装类都是抽象类 Number 的子类：\n\n注意：Number 还有另外四个子类在此未作讨论。BigDecimal 和 BigInteger用于高精度计算，AtomicInteger 和 AtomicLong 则用于多线程应用程序。\n\n使用Number对象而非原始类型可能有以下三个原因：\n\n作为方法的参数，该方法期望接收一个对象（常用于操作数字集合时）。\n使用类定义的常量（如 MIN_VALUE 和 MAX_VALUE），这些常量提供了数据类型的上下界。\n使用类方法将值转换为其他基本类型并反向转换，将值转换为字符串并反向转换，以及在不同数制（十进制、八进制、十六进制、二进制）之间进行转换。\n\n下表列出了Number类所有子类都实现的实例方法。\n以下方法将此Number对象的值转换为返回的原始数据类型。\n\nbyte byteValue()\nshort shortValue()\nint intValue()\nlong longValue()\nfloat floatValue()\ndouble doubleValue()\n\n以下方法将此 Number 对象与参数进行比较。\n\nint compareTo(Byte anotherByte)\nint compareTo(Double anotherDouble)\nint compareTo(Float anotherFloat)\nint compareTo(Integer anotherInteger)\nint compareTo(Long anotherLong)\nint compareTo(Short anotherShort)\nboolean equals(Object obj)\n\nequals(Object obj) 方法用于判断该数字对象是否与参数相等。若参数不为空且与该对象类型相同、数值相等，则该方法返回 true。对于 Double 和 Float 对象，Java API 文档中还规定了额外要求。\n每个 Number 类都包含其他方法，这些方法可用于将数字转换为字符串或从字符串转换为数字，以及在不同数制之间进行转换。下表列出了 Integer 类中的这些方法。其他 Number 子类的方法与此类似：\n\n\n\n方法\n说明\n\n\n\nstatic Integer decode(String s)\n将字符串解码为整数。可接受十进制、八进制或十六进制数字的字符串表示形式作为输入。\n\n\nstatic int parseInt(String s)\n返回一个整数（仅限十进制）。\n\n\nstatic int parseInt(String s, int radix)\n根据输入的十进制、二进制、八进制或十六进制（基数分别为10、2、8或16）数字的字符串表示形式，返回一个整数。\n\n\nString toString()\n返回一个字符串对象，表示此整数的值。\n\n\nstatic String toString(int i)\n返回一个字符串对象，表示指定的整数。\n\n\nstatic Integer valueOf(int i)\n返回一个整数对象，该对象持有指定基本数据类型的值。\n\n\nstatic Integer valueOf(String s)\n返回一个整数对象，该对象持有指定字符串表示形式的值。\n\n\nstatic Integer valueOf(String s, int radix)\n返回一个Integer对象，该对象包含指定字符串表示形式的整数值，该值使用基数参数进行解析。例如，若s &#x3D; “333”且基数 &#x3D; 8，则该方法返回八进制数333对应的十进制整数值。\n\n\n格式化数值打印输出先前您已看到使用 print 和 println方法将字符串输出到标准输出 System.out 的用法（这篇文章是2021年写的，当时还没有IO.println()方法，所以这里还是System.out方法）。由于所有数字均可转换为字符串，您可利用这些方法输出任意混合的字符串与数字。然而Java编程语言还提供了其他方法，当输出包含数字时，这些方法能让您对打印结果实现更精细的控制。\nPrintf 和 Format 方法java.io 包包含一个 PrintStream 类，该类提供了两个格式化方法，可用于替代 print 和 println。这两个方法 format 和 printf 功能等效。你一直使用的 System.out 恰好是一个 PrintStream 对象，因此可以在 System.out 上调用 PrintStream 的方法。这样，在代码中任何原本使用 print 或 println 的位置，你都可以改用 format 或 printf。例如：\nSystem.out.format(.......);\n\n这两个 java.io.PrintStream 方法的语法相同：\npublic PrintStream format(String format, Object... args)\n其中 format 是指定格式化样式的字符串，args 是采用该格式化样式打印的变量列表。一个简单的示例如下：\nSystem.out.format(\"The value of \" + \"the float variable is \" +\n     \"%f, while the value of the \" + \"integer variable is %d, \" +\n     \"and the string is %s\", floatVar, intVar, stringVar); \n第一个参数 format 是一个格式字符串，用于指定如何格式化第二个参数 args 中的对象。该格式字符串包含纯文本以及格式指定符——这些特殊字符用于格式化 Object… args 的参数。（Object… args 的表示法称为 varargs，表示参数数量可能变化。）格式指定符以百分号(%)开头，以转换符结尾。转换符是一个字符，用于指示待格式化的参数类型。在百分号(%)与转换符之间，可选地包含标志符和指定符。转换符、标志符和指定符种类繁多，其详细说明详见java.util.Formatter类文档。\n示例如下:\nint i = 461012;\nSystem.out.format(\"The value of i is: %d%n\", i);\n%d 指定该单一变量为十进制整数。%n 是平台无关的换行符。输出结果为：\nThe value of i is: 461012\nprintf 和 format 方法具有重载特性。每种方法都包含以下语法的版本：\npublic PrintStream format(Locale l, String format, Object... args)\n要按法语系统打印数字（该系统使用逗号代替英语浮点数表示法中的小数点），例如，可使用：\nSystem.out.format(Locale.FRANCE,\n    \"The value of the float \" + \"variable is %f, while the \" +\n    \"value of the integer variable \" + \"is %d, and the string is %s%n\", \n    floatVar, intVar, stringVar);\n一个例子下表列出了在随后的示例程序 TestFormat.java 中使用的部分转换器和标志。\n\n\n\n转换器\n标志位\n说明\n\n\n\nd\n\n十进制整数\n\n\nf\n\n浮点数\n\n\nn\n\n适用于运行应用程序的平台的新行字符。应始终使用 %n，而非 \\n。\n\n\ntB\n\n日期与时间转换——特定区域的月份全称。\n\n\ntd,te\n\n日期与时间转换——月内日期采用两位数表示。td格式会根据需要添加前导零，te格式则不添加。\n\n\nty,tY\n\n日期与时间转换——ty &#x3D; 2位年份，tY &#x3D; 4位年份。\n\n\ntl\n\n日期与时间转换——12小时制中的小时。\n\n\ntM\n\n日期与时间转换——分钟采用两位数表示，必要时补零。\n\n\ntp\n\n日期与时间转换——区域设置特定的上午&#x2F;下午（小写）。\n\n\ntm\n\n日期与时间转换——月份采用两位数表示，必要时补零。\n\n\ntD\n\n日期与时间转换——等同于 %tm&#x2F;%td&#x2F;%ty 格式。\n\n\n\n08\n宽度为八个字符，必要时补零。\n\n\n\n+\n包含符号，无论是正号还是负号。\n\n\n\n,\n包含特定区域设置的分组字符。\n\n\n\n-\n左对齐。\n\n\n\n.3\n小数点后保留3位。\n\n\n\n10.3\n宽度为10个字符，小数点后保留3位。\n\n\n以下程序展示了使用format函数可实现的部分格式化效果。运行程序后自行查看输出结果：\npublic class TestFormat &#123;\n    public static void main(String[] args) &#123;\n        long n = 461012;\n        System.out.format(\"%d%n\", n);\n        System.out.format(\"%08d%n\", n);\n        System.out.format(\"%+8d%n\", n);\n        System.out.format(\"%-8d%n\", n);\n        System.out.format(\"%,8d%n\", n);\n        System.out.format(\"%+,8d%n%n\", n);\n\n        double pi = Math.PI;\n        System.out.format(\"%f%n\", pi);\n        System.out.format(\"%.3f%n\", pi);\n        System.out.format(\"%10.3f%n\", pi);\n        System.out.format(\"%-10.3f%n\", pi);\n        System.out.format(Locale.FRANCE,\"%-10.4f%n%n\", pi);\n\n        Calendar c = Calendar.getInstance();\n        System.out.format(\"%tB %te, %tY%n\", c, c, c);\n        System.out.format(\"%tl:%tM %tp%n\", c,  c, c);\n        System.out.format(\"%tD%n\", c);\n    &#125;\n&#125;\n\n注：本节讨论仅涉及格式化和printf方法的基础知识。更多细节可参阅本教程中”基本输入输出”部分的”格式化”页面。使用String.format()创建字符串的内容详见字符串章节。\n\nDecimalFormat 类您可以使用 java.text.DecimalFormat 类来控制数字显示方式，包括控制前导零和尾随零的显示、添加前缀和后缀、设置千位分隔符以及小数点分隔符。DecimalFormat 在数字格式化方面提供了极大的灵活性，但可能会增加代码的复杂性。下面的示例通过向 DecimalFormat 构造函数传递模式字符串来创建一个 DecimalFormat 对象 myFormatter。随后由 myFormatter 调用格式化方法（该方法由 DecimalFormat 继承自 NumberFormat），该方法接受一个 double 值作为参数，并返回格式化后的数字字符串。\n以下是一个演示DecimalFormat用法示例程序：\npublic class DecimalFormatDemo &#123;\n    public static void main(String[] args) &#123;\n        customFormat(\"###,###.###\", 123456.789);\n        customFormat(\"###.##\", 123456.789);\n        customFormat(\"$###,###.###\", 123456.789);\n        customFormat(\"000000.000\", 123.78);\n    &#125;\n\n    public static void customFormat(String pattern, double value) &#123;\n        DecimalFormat myFormatter = new DecimalFormat(pattern);\n        String output = myFormatter.format(value);\n        IO.println(value + \"    \" + pattern + \"    \" + output);\n    &#125;\n&#125;\n输出结果为：\n123456.789    ###,###.###    123,456.789\n123456.789    ###.##    123456.79\n123456.789    $###,###.###    $123,456.789\n123.78    000000.000    000123.780\n\n\n超越基础算术Java编程语言通过其算术运算符支持基本算术运算：+、-、*、&#x2F; 和 %。位于 java.lang 包中的 Math 类提供了用于执行更高级数学计算的方法和常量。\nMath 类中的方法均为静态方法，因此可直接从类中调用，如下所示：\nMath.cos(angle);\n\n注意：使用静态导入语言特性后，无需在每个数学函数前添加 Math 前缀：import static java.lang.Math.*; 这使您能够通过简单名称调用 Math 类的方法。例如：cos(angle);\n\n常量与基本方法Math 类定义了两个常量：\n\nMath.E：自然对数的底数，约为 2.718。\nMath.PI: 圆周率\n\n数学类还包含40多个静态方法。下表列出了若干基本方法。\n计算绝对值\ndouble abs(double d)\nfloat abs(float f)\nint abs(int i)\nlong abs(long l)\n\n四舍五入一个值\ndouble ceil(double d)：返回大于或等于参数的最小整数。以 double 类型返回。\ndouble floor(double d)：返回小于或等于参数的最大整数。返回值为双精度浮点数。以 double 类型返回。\ndouble rint(double d)：返回与参数数值最接近的整数。以 double 类型返回。\nlong round(double d) 和 int round(float f)： 返回最接近参数的 long 或 int 类型值（具体取决于方法的返回类型）。\n\n后续还列举了很多方法，这里不再展开，可以参考API文档。\n以下程序 BasicMathDemo 演示了如何使用其中一些方法：\npublic class BasicMathDemo &#123;\n    public static void main(String[] args) &#123;\n        double a = -191.635;\n        double b = 43.74;\n        int c = 16, d = 45;\n\n        System.out.printf(\"The absolute value of %.3f is %.3f%n\", a, Math.abs(a));\n        System.out.printf(\"The ceiling of %.2f is %.0f%n\", b, Math.ceil(b));\n        System.out.printf(\"The floor of %.2f is %.0f%n\", b, Math.floor(b));\n        System.out.printf(\"The rint of %.2f is %.0f%n\", b, Math.rint(b));\n        System.out.printf(\"The max of %d and %d is %d%n\", c, d, Math.max(c, d));\n        System.out.printf(\"The min of %d and %d is %d%n\", c, d, Math.min(c, d));\n    &#125;\n&#125;\n程序输出如下：\nThe absolute value of -191.635 is 191.635\nThe ceiling of 43.74 is 44\nThe floor of 43.74 is 43\nThe rint of 43.74 is 44\nThe max of 16 and 45 is 45\nThe min of 16 and 45 is 16\n\n指数与对数方法下表列出了 Math 类的指数和对数方法。\n\ndouble exp(double d)：返回自然对数的底数 e 的幂次，该幂次为参数的值。\ndouble log(double d)：返回参数的自然对数。\ndouble pow(double base, double exponent)：返回以第一个参数为指数，第二个参数为幂次的值。\ndouble sqrt(double d)：返回参数的平方根。\n\n以下程序 ExponentialDemo 将显示自然对数底e的值，然后对随机选取的数值依次调用上表中列出的各项方法：\npublic class ExponentialDemo &#123;\n    public static void main(String[] args) &#123;\n        double x = 11.635;\n        double y = 2.76;\n        \n        System.out.printf(\"The value of e is %.4f%n\", Math.E);\n        System.out.printf(\"exp(%.3f) is %.3f%n\", x, Math.exp(x));\n        System.out.printf(\"log(%.3f) is %.3f%n\", x, Math.log(x));\n        System.out.printf(\"pow(%.3f, %.3f) is %.3f%n\", x, y, Math.pow(x, y));\n        System.out.printf(\"sqrt(%.3f) is %.3f%n\", x, Math.sqrt(x));\n    &#125;\n&#125;\n输出如下：\nThe value of e is 2.7183\nexp(11.635) is 112983.831\nlog(11.635) is 2.454\npow(11.635, 2.760) is 874.008\nsqrt(11.635) is 3.411\n\n后面还有三角函数的例子，这里就不再继续展开了。\n随机数random() 方法返回一个在 0.0 到 1.0 之间伪随机选取的数值。该范围包含 0.0 但不包含 1.0，即满足：0.0 &lt;&#x3D; Math.random() &lt; 1.0。若需获取不同范围的数值，可对随机方法返回值进行算术运算。例如要生成 0 到 9 之间的整数，可编写如下代码：\nint number = (int)(Math.random() * 10);\n通过将数值乘以10，可能取值的范围变为 0.0 ≤ number &lt; 10.0。\n当需要生成单个随机数时，使用 Math.random 效果良好。若需生成随机数序列，应创建 java.util.Random 的实例，并调用该对象的方法来生成数值。\n","categories":["技术","Java"],"tags":["Java Programming Language"]},{"title":"基础数据类型","url":"//technology/java/primitive-data-types/","content":"前面说到字段，Java编程语言也使用变量这个术语，字段更多是用在OOP中的上下文。这篇将介绍变量和字段之间的联系，加上变量的命名规则和约定俗成的命名规范。，基础数据类型(基本类型，字符串和数组)，默认值和字面量。  \n\n\n基本类型Java编程语言是静态类型的，意思就是所有的变量必须在使用之前就声明好。这包含两个方面：变量的类型和名称。如你所见：\nint gear = 1;\n\n这样就告诉你的程序，我要一个叫gear的字段，保存一个数值类型，并且初始化值为1。一个变量的数据类型决定了它能保存什么样的值，加上它能执行什么样的操作。除了 int 之外，Java还支持七种不同的基本数据类型。基本数据类型是语言内置的预定义的数据类型。它们的名称都是保留字，不能用做变量名。基本值不与其他基本值共享状态。Java一共有8种基本数据类型：  \n\n\nbyte: byte 数据类型是一个8位有符号二进制补码整数。它的最小值是 -128（-2^7），最大值是 127（2^7-1）。当节约内存变得很重要的时候，字节数据类型对于节省大型数据的内存空间很又用。它们也可以用来替代 int 类型，其限制性有助于代码更清晰。\nshort: short 数据类型是一个16位有符号二进制补码整数。它的最小值是-32,768(-2^15)，最大值是32,767(2^15-1)。如同 byte，你也可以用它来节省内存空间。\nint: 默认情况下，int 是一个32位有符号二进制补码整数。最小值是-2^31，最大值是2^31-1。\nlong: long 数据类型是一个64位有符号二进制补码整数。它的最小值是-2^63，最大值是2^63-1。\nfloat: float 数据类型是一个单精度32位 IEEE 754 浮点数。它的范围不在这里详述，等到后面讲到浮点数时再说。和 byte 与 short 一样，如果你需要在一个大型数组中节省内存空间，使用 float 替代 double 来表示一个小数。这个数据类型绝对不要用来表示精确的值，比如货币。对于这种情况，使用类 java.math.BigDecimal 替代，后面会讲到这个类。\ndouble: double 数据类型是一个双精度64位 IEEE 754 浮点数。这里也不讨论它的范围，等到后面讲到浮点数时再说。正如上面提到的，double 不要用来表示精确的值，比如货币。\nboolean: boolean 数据类型只有两个取值：true 和 false。使用这个数据类型来表示条件的 true&#x2F;false 状态。虽然 boolean 只表示1位的信息，但它的“大小”并没有明确的规定。在某些虚拟机中，boolean 可能是用一个字节来表示，而在其他虚拟机中可能是用一个整数来表示。\nchar: char 数据类型是一个单一的16位 Unicode 字符。它的最小值是\\u0000（即0），最大值是 \\uffff（即65,535）。\n\n\n注意到，在Java 8 及之后的版本，你可以使用 int 类型来表示一个无符号32位整数，它的最小值是0,最大值是2^32-1。使用 Integer 类来表示一个无符号整数。该类的静态方法像 Integer.compareUnsigned() 支持无符号整数的算术运算。  \nJava 8 及以后的版本也可以使用 long 来表示一个无符号64位long整数，它的最小值是0，最大值是2^64-1。如果你需要表示一个范围超过int的数，就这个这个类型。Long 类提供了 Long.compareUnsigned()，Long.divideUnsigned() 等方法来支持无符号长整数的算术运算。  \n除了上面这8种基本数据类型，Java通过 java.lang.String 类来支持字符串。使用双引号包围起来的字符会自动地创建一个 String 对象，像这样子：\nString s =  \"this is a string\";\nString 对象都是不可变的，这意味着一旦被创建，它们的值无法被更改。严格的说String 类不是基本数据类型，但考虑到Java对其提供的特殊支持，你可能也会把它视为基本数据类型。后面讲String类的时候会更详细地介绍它。\n使用默认值初始化变量在声明字段时，并非总是能有一个值，你可能不知道当前的值是什么。编译器会将声明但未初始化的字段设置为一个默认值。一般而言，该默认值为 0 或者 null，取决于数据类型。如果总是依赖于编译器给默认值，通常来说不是一个好的编程习惯。下面的表格总结了以上8种基本数据类型的默认值：\n\n\n\nDate Type\nDefault Value(for fields)\n\n\n\nbyte\n0\n\n\nshort\n0\n\n\nint\n0\n\n\nlong\n0L\n\n\nfloat\n0.0f\n\n\ndouble\n0.0d\n\n\nchar\n\\u0000\n\n\nString(or any object)\nnull\n\n\nboolean\nfalse\n\n\n局部变量有一点点不同。编译器从不分配一个默认值给一个未初始化的局部变量。如果你在声明时不初始化你的局部变量，确保你在使用它之前给它赋值。防卫一个未被处死绘画的局部变量会返回一个编译时错误。\n使用字面量初始化变量你可能会注意到上面的代码中没有使用new关键字初始化基本类型的变量。基本类型是一种特殊的数据类型被内置在编程语言中。它们不是一个从类创建的对象。字面量一代码层面上的固定值，字面量不需要经过计算就可以直接在代码中使用。如下所示，可以将字面量赋值给一个基本类型的变量：\nboolean result = true;\nchar capitalC = 'C';\nbyte b = 100;\nshort s = 10000;\nint i = 100000;\n\n\n整型字面量如果一个整型字面量以l或L结尾，它会被当作一个long类型，否则它会被当作一个int类型。推荐使用大写的L来表示long类型，以避免和数字1混淆。 \n整数类型byte,short,int和long的值都可以由int字面量创建。超过int表示范围的long类型可以用long字面量创建。整型字面量可以被表达为以下几种数制：\n\n\nDecimal:十进制，其数字由0到9组成。这是你日常使用的数制。\nHexadecimal: 十六进制，其数字由0到9和A到F组成。\nBinary: 二进制，其数字由0和1组成。从Java 7开始，Java支持二进制字面量。\n\n\n对于通常的编程任务，十进制很可能是你最常用的数制。然后，当你需要使用另一种数制的时候，虾米那的例子展示了正确的语法。前缀0x表明这是十六进制数，前缀0b表明是二进制数：\n// The number 26, in decimal\nint decimalValue = 26;\n\n// The number 26, in hexadecimal\nint hexadecimalValue = 0x1A;\n\n// The number 26, in binary\nint binaryValue = 0b11010;\n\n浮点数字面量用F或者f结尾的浮点数字面量会被当作float类型，否则它会被当作double类型，可选地在结尾用D或者d来表示double类型。浮点类型（float 和 double）也可使用 E 或 e（表示科学记数法）、F 或 f（表示 32 位浮点数字面量）以及 D 或 d（表示 64 位双精度数字面量；此为默认形式，按惯例可省略）来表示。\ndouble d1 = 123.4;\n// same value as d1, but in scientific notation\ndouble d2 = 1.234e2;\nfloat f1 = 123.4f;\n\n字符和字符串字面量char 和 String 类型的字面量可包含任意 Unicode（UTF-16）字符。若您的编辑器和文件系统支持，可直接在代码中使用此类字符。若不支持，可使用 Unicode 转义序列，例如 \\u0108（带楔形符号的大写 C）或 “S\\u00ED Se\\u00F1or”（西班牙语中的 Sí Señor）。字符常量始终使用’单引号’，字符串常量始终使用”双引号”。Unicode转义序列不仅限于字符或字符串常量，在程序其他位置（如字段名称）也可使用。  \nJava 编程语言还为字符和字符串字面量支持若干特殊转义序列：\\b（退格）、\\t（制表符）、\\n（换行符）、\\f（分页符）、\\r（回车符）、\\“（双引号）、\\‘（单引号）以及 \\\\\\（反斜杠）。  \n还存在一种特殊的空值字面量，可作为任何引用类型的值使用。空值字面量可赋值给除基本类型变量外的任何变量。除了检测其存在性外，空值几乎无法执行其他操作。因此，在程序中常将空值用作标记符，表示某些对象不可用。  \n最后，还存在一种特殊的字面量称为类字面量，其形式是在类型名称后附加.class；例如String.class。这指代的是代表类型本身的对象，其类型为Class。  \n在数字字面量中使用下划线字符在 Java SE 7 及更高版本中，数字字面量中的任意数字之间可以出现任意数量的下划线字符 (_)。此功能可让您在数字字面量中分隔数字组，从而提高代码的可读性。例如，如果你的代码包含多位数字，可以使用下划线字符将数字分隔为三位一组，类似于使用逗号或空格等标点符号作为分隔符的方式。以下示例展示了在数字字面量中使用下划线的其他方式：\nlong creditCardNumber = 1234_5678_9012_3456L;\nlong socialSecurityNumber = 999_99_9999L;\nfloat pi = 3.14_15F;\nlong hexBytes = 0xFF_EC_DE_5E;\nlong hexWords = 0xCAFE_BABE;\nlong maxLong = 0x7fff_ffff_ffff_ffffL;\nbyte nybbles = 0b0010_0101;\nlong bytes = 0b11010010_01101001_10010100_10010010;\n\n下划线只能放置在数字之间，以下位置不能使用下划线：\n\n在数字的开头或结尾处\n在浮点数字面量中紧邻小数点的位置\n在F或L后缀之前\n在预期出现用字符串表示的数字序列的位置\n\n以下示例展示了数字字面量中下划线的有效与无效位置：\n// Invalid: cannot put underscores\n// adjacent to a decimal point\nfloat pi1 = 3_.1415F;\n// Invalid: cannot put underscores\n// adjacent to a decimal point \nfloat pi2 = 3._1415F;\n// Invalid: cannot put underscores\n// prior to an L suffix\nlong socialSecurityNumber1 = 999_99_9999_L;\n\n// OK (decimal literal)\nint x1 = 5_2;\n// Invalid: cannot put underscores\n// At the end of a literal\nint x1 = 52_;\n//OK (decimal literal)\nint x3 = 5________2;\n\n// Invalid: cannot put underscores\n// in the 0x radix prefix\nint x4 = 0_x52;\n// Invalid: cannot put underscores\n// at the beginning of a number\nint x5 = 0x_52;\n// OK (hexadecimal literal)\nint x6 = 0x5_2;\n// Invalid: cannot put underscores\n// at the end of a number\nint x7 = 0x52_;","categories":["技术","Java"],"tags":["Java Programming Language"]},{"title":"Switch 表达式","url":"//technology/java/switch-expression/","content":"在 Java SE 14 中，您可以使用另一种更便捷的 switch 关键字语法：switch 表达式。\n促成这种新语法的设计有以下几个因素。\n\n默认情况下，switch 标签之间的控制流行为是继续执行后续语句。这种语法容易出错，并导致应用程序出现缺陷。\nswitch 表达式被视为一个整体块。当您需要仅在特定情况下定义变量时，这可能构成障碍。\nswitch 语句是一种语句。在前几节的示例中，每个分支都为变量赋值。将其改为表达式可能使代码更优雅且更易于阅读。\n\n\n上一节介绍的语法结构称为switch语句，在Java SE 14中仍然可用，其语义未发生改变。从Java SE 14开始，switch语句新增了一种语法形式：switch 表达式。此语法修改了switch标签的语法。假设您的应用程序中有以下switch语句：\nDay day = ...; // any day\nint len = 0;\nswitch(day)&#123;\n    case MONDAY:\n    case FRIDAY:\n    case SUNDAY:\n        len = 6;\n        break;\n    case TUESDAY:\n        len = 7;\n        break;\n    case THURSDAY:\n    case SATURDAY:\n        len = 8;\n        break;\n    case WEDNESDAY:\n        len = 9;\n        break;\n&#125;\nIO.println(\"len = \" + len);\n\n使用 switch 表达式语法，现在可以按以下方式编写代码。\nDay day = ...; // any day\nint len = \n    switch (day)&#123;\n        case MONDAY, FRIDAY, SUNDAY -> 6;\n        case TUESDAY                -> 7;\n        case THURSDAY, SATURDAY     -> 8;\n        case WEDNESDAY              -> 9;\n    &#125;;\nIO.println(\"len = \" + len);\nswitch标签的语法现为 case L -&gt;。仅当标签匹配时，才会执行标签右侧的代码。该代码可以是单个表达式、代码块或throw语句。由于这段代码构成一个独立代码块，您可以在其中定义仅作用于该代码块的局部变量。\n此语法还支持每个case包含多个常量，用逗号分隔，如前例所示。\n生成一个值此 switch 语句可作为表达式使用。例如，前一节的示例可通过 switch 语句重写如下：\nint quarter =  ...; // any value\nString quarterLabel = \n    switch (quarter) &#123;\n        case 0 -> \"Q1 - Winter\";\n        case 1 -> \"Q2 - Spring\";\n        case 2 -> \"Q3 - Summer\";\n        case 3 -> \"Q3 - Summer\";\n        default -> \"Unknown quarter\";\n    &#125;\n如果 case 块中只有一条语句，则该语句生成的值将由 switch 表达式返回。在代码块的情况下，语法略有不同。传统上，return 关键字用于表示代码块生成的值。遗憾的是，这种语法在 switch 语句中会导致歧义。让我们考虑以下示例。这段代码无法编译，仅作为示例存在。\n// Be careful, this code does not compile!\npublic String convertToLabel(int quarter) &#123;\n    String quarterLabel =\n        switch( quarter)&#123;\n            case 0 -> &#123;\n                IO.println(\"Q1 - Winter\");\n                return \"Q1 - Winter\";\n            &#125;\n            default -> \"Unknown quarter\";\n        &#125;;\n        return quarterLabel;\n&#125;\n当 quarter 等于 0 时执行的代码块需要返回一个值。它使用 return 关键字来表示该值。仔细观察这段代码，你会发现存在两个 return 语句：一个位于 case 代码块中，另一个位于方法主体中。这正是歧义所在：人们可能会疑惑第一个 return 的语义含义——它表示程序将带着此值退出方法？还是说将退出 switch 语句？此类歧义导致代码可读性差且易出错。为了解决这种歧义，创建了一种新的语法：yield语句。前面的示例代码应改写为以下形式。\npublic String convertToLabel(int quarter) &#123;\n    String quarterLabel =\n        switch( quarter)&#123;\n            case 0 -> &#123;\n                IO.println(\"Q1 - Winter\");\n                yield \"Q1 - Winter\";\n            &#125;\n            default -> \"Unknown quarter\";\n        &#125;;\n        return quarterLabel;\n&#125;\nyield 语句是一种可在 switch 语句任意 case 块中使用的语句。它会返回一个值，该值将成为包含它的 switch 语句的返回值。\n增加默认分支这段我没看太明白。switch expression 和 switch statement 一样，建议总是包含 default 分支，以防输入值不在预期范围内。\n在 switch 表达式中使用冒号规则讲真，这段我也没看太明白。我个人不推荐在 switch expressions 中 使用 switch statements 的冒号规则，容易混淆。\nNull 值处理Java SE 17 引入了对 switch 表达式中 null 值的处理支持。您可以在 switch 表达式中添加一个 case null 分支，以处理可能为 null 的输入值。例如：\npublic class SwitchExpressionDemo &#123;\n\n    public static void main(String[] args) &#123;\n        IO.println(processInput(null));\n    &#125;\n\n    static String processInput(String input) &#123;\n        return switch (input) &#123;\n            // 显式处理 null\n            case null ->\n                \"输入为空，请提供有效值。\";\n\n            // 处理其他有效字符串\n            case \"A\" ->\n                \"处理类型 A\";\n            case \"B\" ->\n                \"处理类型 B\";\n\n            // default 块处理所有非 null 且未匹配的值\n            default ->\n                \"未知输入\";\n        &#125;;\n    &#125;\n&#125;\n程序运行结果为：\n输入为空，请提供有效值。","categories":["技术","Java"],"tags":["Java Programming Language"]},{"title":"使用Record建模不可变数据","url":"//technology/java/record/","content":"Java语言提供了多种创建不可变类的方法。最直接的方式可能是创建一个包含final字段和构造函数的final类，用于初始化这些字段。以下是一个此类类的示例。\npublic class Point &#123;\n    private final int x;\n    private final int y;\n\n    public Point(int x, int y) &#123;\n        this.x = x;\n        this.y = y;\n    &#125;\n&#125;\n\n既然你已经编写了这些元素，接下来需要为字段添加访问器方法。你还需要添加 toString() 方法，可能还需要 equals() 方法以及 hashCode() 方法。手动编写所有这些方法相当繁琐且容易出错，所幸你的集成开发环境（IDE）可以为你自动生成这些方法。\n若需将该类的实例从一个应用程序传递至另一个应用程序（无论是通过网络传输还是文件系统传输），您也可考虑使该类具备序列化能力。若选择此方案，您可能需要添加关于该类实例序列化方式的相关信息。JDK提供了多种控制序列化的方法。\n最终，你的 Point 类可能长达上百行，其中大部分是IDE生成的代码，仅仅是为了建模一个需要写入文件的两个整数的不可变聚合。\n为改变这种状况，JDK引入了Record类型。Record类型只需一行代码就能实现这一切。你只需声明记录的状态，其余部分由编译器自动生成。\n呼唤Record来解救Record的存在正是为了帮助你简化这段代码。从Java SE 14开始，你可以编写以下代码：\npublic record Point(int x, int y) &#123;&#125;\n这行代码为您创建了以下元素。\n\n这是一个不可变类，包含两个字段：x 和 y，类型均为 int。\n它具有一个标准构造函数，用于初始化这两个字段。\n编译器已为您创建了 toString()、equals() 和 hashCode() 方法，其默认行为与IDE生成的行为一致。如有需要，您可以通过添加这些方法的自定义实现来修改其行为。\n它可以实现 Serializable 接口，从而能够通过网络或文件系统将Point实例发送至其他应用程序。记录的序列化和反序列化过程遵循特定规则，这些规则将在本教程末尾进行说明。\n\nRecord 使创建不可变数据集合变得更加简单，无需任何IDE的辅助。它降低了出现错误的风险，因为每次修改记录的组件时，编译器都会自动为您更新 equals() 和 hashCode() 方法。\nRecord类型的类记录是用 record 关键字而不是 “class 关键字声明的类。让我们声明以下记录。\npublic record Point(int x, int y) &#123;&#125;\n当你创建记录时，编译器为你生成的类是final的。该类继承自 java.lang.Record 类。因此您的记录类不能继承任何其他类。一个记录可以实现任意数量的接口。\n声明Record的组成部分紧接Record name之后的代码块为 (int x, int y)。该代码块声明了名为 Point 的Record的组成部分。对于记录的每个组成部分，编译器都会创建一个与该组成部分同名的私有 final 字段。记录中可以声明任意数量的组成部分。在此示例中，编译器创建了两个私有最终字段，类型为 int：x 和 y，分别对应您声明的两个组件。除了这些字段外，编译器还会为每个组件生成一个访问器。该访问器是一个方法，其名称与组件相同，并返回其值。对于此Point记录，生成的两个方法如下：\npublic int x() &#123;\n    return this.x;\n&#125;\npublic int y() &#123;\n    return this.y;\n&#125;\n如果此实现适用于您的应用程序，则无需添加任何内容。不过，您可以定义自己的访问器方法。当需要返回某个字段的防御性副本时，这可能很有用。编译器为您生成的最后几个元素是对Object类中toString()、equals()和hashCode()方法的重写。如有需要，您可以自行定义这些方法的重写版本。\n无法向Record添加的内容有三件事你无法添加到记录中：\n\n在记录中不能声明任何实例字段。不能添加任何不对应于组件的实例字段。\n您无法定义任何字段初始化器。\n您无法添加任何实例初始化器。\n\n您可以使用初始化器和静态初始化器创建静态字段。\n使用规范构造函数构建Record编译器还会为你创建一个构造函数，称为canonical constructor。该构造函数将记录的各个组件作为参数，并将它们的值复制到Record类的字段中。在某些情况下，您需要覆盖此默认行为。让我们来探讨两个用例：\n\n您需要验证Record的状态\n你需要对可变组件创建一个防御性副本。\n\n使用紧凑构造函数您可以使用两种不同的语法来重新定义记录的规范构造函数。您可以使用紧凑构造函数或规范构造函数本身。假设你有以下记录。\npublic record Range(int start, int end) &#123;&#125;\n对于名为Range的记录，人们会期待end比start大。你可以在记录中编写紧凑构造函数来添加验证规则。\npublic record Range(int start, int end) &#123;\n    public Range &#123;\n        if (end &lt; start) &#123;\n            throw new IllegalArgumentException(\"End cannot be lesser than start\");\n        &#125;\n    &#125;\n&#125;\n紧凑的规范构造函数无需声明其参数块。请注意，若选择此语法，您无法直接赋值记录字段（例如使用 this.start &#x3D; start），因为编译器生成的代码会自动完成此操作。但您可以为参数赋予新值，这将产生相同效果——编译器生成的代码会将这些新值赋予字段。\npublic Range &#123;\n    // set negtive start and end to 0\n    // by reassigning the compact constructor's\n    // implicit parameters\n    if (start &lt; 0) &#123;\n        start = 0;\n    &#125;\n    if (end &lt; 0) &#123;\n        end = 0;\n    &#125;\n&#125;\n\n使用规范构造函数若您更倾向于使用非紧凑形式（例如因不愿重新赋值参数），可自行定义规范构造函数，如下例所示：\npublic record Range(int start, int end) &#123;\n\n    public Range(int start, int end) &#123;\n        if (end &lt;= start) &#123;\n            throw new IllegalArgumentException(\"End cannot be lesser than start\");\n        &#125;\n        if (start &lt; 0) &#123;\n            this.start = 0;\n        &#125; else &#123;\n            this.start = start;\n        &#125;\n        if (end > 100) &#123;\n            this.end = 10;\n        &#125; else &#123;\n            this.end = end;\n        &#125;\n    &#125;\n&#125;\n在这种情况下，你编写的构造函数需要为记录的字段赋值。如果记录的组件不可变，您应考虑在规范构造函数和访问器中为其创建防御性副本。\n定义任意构造函数您也可以为记录添加任何构造函数，只要该构造函数调用记录的规范构造函数即可。其语法与使用另一个构造函数调用构造函数的经典语法相同。与任何类一样，this() 的调用必须是构造函数中的第一条语句。\n让我们审视以下 State record。它由三个组成部分定义：\n\n国家的名称\n该国的首都名称\n一个城市名称的列表，可能为空我们需要存储城市列表的防御性副本，以确保该列表不会被本记录外部修改。这可以通过重新定义规范构造函数来实现，采用紧凑形式将参数重新赋值给防御性副本。在您的应用程序中，提供一个不接收任何城市参数的构造函数会很有用。这可以是另一个构造函数，仅接收州名和首府城市名。该第二个构造函数必须调用标准构造函数。那么，与其传递一个城市列表，不如将城市作为可变参数传递。为此，可以创建第三个构造函数，该构造函数必须调用标准构造函数并传入正确的列表。\n\nimport java.util.List;\n\npublic record State(String name, String capitalCity, List&lt;String> cities) &#123;\n\n    public State   &#123;\n        cities = List.copyOf(cities);\n    &#125;\n\n    public State(String name, String capitalCity) &#123;\n        this(name, capitalCity, List.of());\n    &#125;\n\n    public State(String name, String capitalCity, String... cities) &#123;\n        this(name, capitalCity, List.of(cities));\n    &#125;\n&#125;\n请注意，List.copyOf() 方法不接受 null 值。\n获取一个Record的状态您无需为记录添加任何访问器，因为编译器会为您完成这项工作。每个记录组件都对应一个访问器方法，该方法的名称即为该组件的名称。本教程第一部分中的Point记录包含两个访问器方法：x()和y()，它们分别返回对应分量的值。\n不过，某些情况下你需要定义自己的访问器。例如，假设上一节中的State记录在构造时未创建cities list的不可修改的防御性副本——那么它应在访问器中执行此操作，以确保调用者无法修改其内部状态。你可以在State记录中添加以下代码来返回该防御性副本：\npublic List&lt;String> cities() &#123;\n    return List.copyOf(cities);\n&#125;\n\n序列化Record如果记录类实现了Serializable接口，则可以进行序列化和反序列化。但存在一些限制。\n\n对于记录而言，没有任何可替代默认序列化过程的系统可用。创建 writeObject() 和 readObject() 方法无效，实现 Externalizable 接口同样无效。\n记录可作为代理对象用于序列化其他对象。readResolve()方法可返回记录对象。在记录中添加writeReplace()方法同样可行。\n反序列化记录时始终调用规范构造函数。因此，你在该构造函数中添加的所有验证规则都将在反序列化记录时强制执行。\n\n这使得Record成为在应用程序中创建数据传输对象的绝佳选择。\n在实际用例中使用RecordRecord是一个多功能的概念，可在多种情境中使用。第一种是将数据承载在应用程序的对象模型中。你可以将记录用于其设计初衷：作为不可变的数据载体。由于可以声明局部记录，您也可以利用它们来提高代码的可读性。让我们考虑以下用例。你有两个实体被建模为记录：City 和 State。\npublic record City(String name, State state) &#123;&#125;\n\npublic record State(String name) &#123;&#125;\n\n假设你有一份城市列表，需要计算拥有最多城市的州。你可以使用流式处理API，首先构建各州城市数量的直方图。该直方图通过Map对象进行建模。\nList&lt;City> cities = List.of();\n\nMap&lt;State, Long> numberOfCitiesPerState =\n    cities.stream()\n          .collect(Collectors.groupingBy(\n                   City::state, Collectors.counting()\n          ));\n获取此直方图的最大值的通用代码如下：\nMap.Entry&lt;State, Long> stateWithTheMostCities =\n    numberOfCitiesPerState.entrySet().stream()\n                          .max(Map.Entry.comparingByValue())\n                          .orElseThrow();\n这段代码属于技术层面的实现，不承载任何业务含义；因为它使用Map.Entry实例来建模直方图的每个元素。\n使用local record可显著改善此情况。以下代码创建了一个新的记录类，该类聚合了某个州及其所辖城市数量的信息。其构造函数接受Map.Entry实例作为参数，用于将键值对流映射为记录流。\n由于需要按城市数量比较这些聚合数据，可以添加工厂方法来提供此比较器。代码如下所示：\nrecord NumberOfCitiesPerState(State state, long numberOfCities) &#123;\n\n    public NumberOfCitiesPerState(Map.Entry&lt;State, Long> entry) &#123;\n        this(entry.getKey(), entry.getValue());\n    &#125;\n\n    public static Comparator&lt;NumberOfCitiesPerState> comparingByNumberOfCities() &#123;\n        return Comparator.comparing(NumberOfCitiesPerState::numberOfCities);\n    &#125;\n&#125;\n\nNumberOfCitiesPerState stateWithTheMostCities =\n    numberOfCitiesPerState.entrySet().stream()\n                          .map(NumberOfCitiesPerState::new)\n                          .max(NumberOfCitiesPerState.comparingByNumberOfCities())\n                          .orElseThrow();\n\n您的代码现已实现有意义的最大值提取。代码更具可读性，更易于理解且不易出错，从长远来看也更便于维护。\n","categories":["技术","Java"],"tags":["Java Programming Language"]},{"title":"使用Var类型标识符","url":"//technology/java/var/","content":"Var 关键字从 Java SE 10 开始，您可以使用 var 类型标识符声明局部变量。这样做时，您让编译器决定所创建变量的实际类型。一旦创建，该类型就无法更改。考虑如下示例：\nString message = \"Hello world!\";\nPath path = Path.of(\"debug.log\");\nInputStream stream = Files.newInputStream(path);\n\n在这种情况下，显式声明三个变量 message、path 和  stream 的类型是不必要的。使用 var 类型标识符，前面的代码可以重写如下：\nvar message = \"Hello world!\";\nvar path = Path.of(\"debug.log\");\nvar stream = Files.newInputStream(path);\n\n一些Var的例子以下示例展示了如何使用 var 类型标识符使代码更易于阅读。在此示例中，strings 变量被赋予 List&lt;String&gt; 类型，而 element 变量被赋予 String 类型。\nvar list = List.of(\"one\", \"two\", \"three\", \"four\");\nfor (var element : list) &#123;\n    IO.println(element);\n&#125;\n在此示例中，path 变量属于 Path 类型，而 stream 变量属于 InputStream 类型。\nvar path = Path.of(\"debug.log\");\ntry (var stream = Files.newInputStream(path)) &#123;\n    // process the file\n&#125;\n请注意，在前两个示例中，您使用 var 在 for 语句和 try-with-resources 语句中声明了变量。本教程后续部分将详细讲解这两种语句。\n使用Var的若干限制对 var 类型标识符的使用存在限制。\n\n\n你只能将其用于方法、构造函数和初始化器块中声明的局部变量。\nvar 不能用于字段，也不能用于方法或构造函数参数。\n编译器必须能在变量声明时选择类型。由于空值没有类型，该变量必须带有初始化表达式。\n\n\n根据上述限制，以下类无法编译，因为字段或方法参数不能使用 var 作为类型标识符。\npublic class User &#123;\n    private var name = \"Sue\"; // compiler error\n\n    public void setName(var name) &#123; // compiler error\n        this.name = name;\n    &#125;   \n&#125;\n下面的代码也是如此。\npublic String greetings(int message)&#123;\n    var greetings; //compiler error\n    if (message == 0)&#123;\n        greetings = \"morning\";\n    &#125; else &#123;\n        greetings = \"afternoon\";\n    &#125;\n    return \"Good \" + greetings;\n&#125;","categories":["技术","Java"],"tags":["Java Programming Language"]},{"title":"String Builders","url":"//technology/java/stringbuilder/","content":"StringBuilder 类字符串对象类似于StringBuilder对象，区别在于它们可以被修改。在内部，这些对象被视为包含字符序列的可变长度数组。在任何时候，都可以通过方法调用改变序列的长度和内容。除非String Builder能带来更简洁的代码（参见本节末尾的示例程序）或更优的性能，否则应始终使用字符串。在Java SE 9之前，若需连接大量字符串，向StringBuilder对象追加内容可能更高效。Java SE 9中已优化字符串连接操作，使其效率超越StringBuilder的追加方式。\n\n\n长度和容量StringBuilder 类与 String 类类似，都提供了一个 length() 方法，该方法返回构建器中字符序列的长度。与字符串不同，每个String Builder都具有容量，即已分配的字符空间数量。该容量由 capacity() 方法返回，始终大于或等于长度（通常更大），并会根据需要自动扩展以容纳String Builder中的新增内容。\n您可以使用 StringBuilder 类的以下构造函数：\n\nStringBuilder()：创建一个容量为16（16个空元素）的String Builder。\nStringBuilder(CharSequence cs)：构造一个String Builder，其包含与指定CharSequence相同的字符，并在CharSequence之后附加16个空元素。\nStringBuilder(int initCapacity)：创建一个具有指定初始容量的空String Builder。\nStringBuilder(String s)：创建一个String Builder，其值由指定字符串初始化，并在字符串末尾附加16个空元素。\n\n举个例子，下面的代码:\n// creates empty builder, capacity 16\nStringBuilder sb = new StringBuilder();\n// adds 9 character string at beginning\nsb.append(\"Greetings\");\n将生成一个长度为9、容量为16的字符串构建器：\nStringBuilder 类提供了一些与长度和容量相关的、String 类所不具备的方法：\n\nvoid setLength(int newLength): 设置字符序列的长度。若 newLength 小于 length() 返回值，则截断字符序列末尾的字符；若  newLength 大于 length() 返回值，则在字符序列末尾添加 null 字符。\nvoid ensureCapacity(int minCapacity): 确保容量至少等于指定的最小值。\n\nStringBuilder 的操作StringBuilder 提供的主要操作在 String 中不可用，即 append() 和 insert() 方法，这些方法经过重载可接受任意类型的数据。它们会将参数转换为字符串，然后将该字符串的字符追加或插入到字符串构建器中的字符序列中。其中 append 方法始终将字符添加到现有字符序列的末尾，而 insert 方法则将字符添加到指定位置。\n以下是 StringBuilder 类中的一些方法。\n\n您可以使用 append() 方法将任何基本类型或对象附加到字符串构建器上。在执行追加操作之前，数据会被转换为字符串。\ndelete(int start, int end) 方法从 StringBuilder 的字符序列中删除从 start 到 end - 1（包含 end）的子序列。\n你可以使用 deleteCharAt(int index) 方法删除索引为 index 的字符。\n您可以使用insert(int offset)方法在指定偏移量处插入任意基本类型或对象。这些方法将待插入的元素作为第二个参数接收。在执行插入操作前，数据会被转换为字符串。\n您可以使用replace(int start, int end, String s)和setCharAt(int index, char c)方法替换字符。\n你可以使用reverse()方法来反转此String Builder中字符的顺序。\n你可以使用 toString() 方法返回一个包含构建器中字符序列的字符串。\n\n\n注意：您可以在 StringBuilder 对象上使用任何字符串方法，方法是先通过 StringBuilder 类的 toString() 方法将字符串构建器转换为字符串，然后使用 StringBuilder(String string) 构造函数将字符串重新转换为字符串构建器。\n\nStringBuilder实战在”字符串”章节中列出的 StringDemo 程序，就是一个若使用StringBuilder替代String将更高效的程序示例。StringDemo 实现了回文字符串的反转功能。以下是该程序的代码列表：\npublic class PalindromeDemo &#123;\n    public static void main(String[] args) &#123;\n        String palindrome = \"Dot saw I was Tod\";\n        int len = palindrome.length();\n        char[] tempCharArray = new char[len];\n        char[] charArray = new char[len];\n\n        // put original string in an \n        // array of chars\n        for (int i = 0; i &lt; len; i++) &#123;\n            tempCharArray[i] = palindrome.charAt(i);\n        &#125;\n\n        // reverse array of chars\n        for (int j = 0; j &lt; len; j++) &#123;\n            charArray[j] = \n              tempCharArray[len - 1 - j];\n        &#125;\n\n        String reversePalindrome = new String(charArray);\n        IO.println(reversePalindrome);\n    &#125;\n&#125;\n\n程序运行结果如下\ndoT saw I was toD\n\n为实现字符串反转，程序将字符串转换为字符数组（第一个for循环），将数组反转为第二个数组（第二个for循环），最后再转换回字符串。若将回文字符串转换为字符串构建器，可使用StringBuilder类的reverse()方法。这能使代码更简洁易读：\npublic class StringBuilderDemo &#123;\n    public static void main(String[] args) &#123;\n       String palindrome = \"Dot saw I was Tod\";\n\n       StringBuilder sb = new StringBuilder(palindrome);\n       sb.reverse(); //reverse it\n       IO.println(sb.toString());\n    &#125;\n&#125;\n\n会有同样的输出:\ndoT saw I was toD\n请注意，println() 会打印String Builder，例如：\nIO.println(sb);\n因为 sb.toString() 会被隐式调用，就像 println 调用中任何其他对象的情况一样。\n\n注意：还存在一个StringBuffer类，其功能与StringBuilder类完全相同，区别在于StringBuffer通过同步方法实现了线程安全。除非您绝对需要线程安全的类，否则无需使用StringBuffer。\n\n","categories":["技术","Java"],"tags":["Java Programming Language"]},{"title":"字符串","url":"//technology/java/strings/","content":"创建字符串字符串在Java编程中广泛使用，它是一系列字符的序列。在Java编程语言中，字符串是对象。Java平台提供了 String 类来创建和操作字符串。创建字符串最直接的方式是这样：\nString greeting = \"Hello, World!\";\n在此情况下，“Hello world!”是一个字符串字面量——即代码中用双引号括起来的一系列字符。编译器在代码中遇到字符串字面量时，会创建一个与其值相同的String对象——本例中即为Hello world!。与其他对象一样，你可以使用 new 关键字和构造函数创建 String 对象。String 类提供了十三个构造函数，允许你通过不同来源（如字符数组）为字符串提供初始值：\nchar[] helloArray = &#123; 'H', 'e', 'l', 'l', 'o', '.' &#125;;\nString helloString = new String(helloArray);\nIO.println(helloString);\n\n\n这段代码的最后一行显示了”Hello.”。\n\n注：String类是不可变的，因此一旦创建，字符串对象就无法被修改。String类提供了一系列看似能修改字符串的方法（其中部分方法将在下文讨论）。由于字符串不可变，这些方法实际上是创建并返回一个包含操作结果的新字符串。\n\n字符串长度用于获取对象信息的操作称为访问器方法。字符串可用的访问器方法之一是 length() 方法，该方法返回字符串对象所含字符的数量。执行以下两行代码后，len 等于 17：\nString palindrome = \"Dot saw I was Tod\";\nint len = palindrome.length();\n回文是指对称的单词或句子——忽略大小写和标点符号后，正向和反向拼写相同。以下是一个简短但效率低下的程序，用于反转回文字符串。它调用了字符串方法charAt(i)，该方法返回字符串中第i个字符（从0开始计数）。\npublic class PalindromeDemo &#123;\n    public static void main(String[] args) &#123;\n        String palindrome = \"Dot saw I was Tod\";\n        int len = palindrome.length();\n        char[] tempCharArray = new char[len];\n        char[] charArray = new char[len];\n\n        // put original string in an \n        // array of chars\n        for (int i = 0; i &lt; len; i++) &#123;\n            tempCharArray[i] = palindrome.charAt(i);\n        &#125;\n\n        // reverse array of chars\n        for (int j = 0; j &lt; len; j++) &#123;\n            charArray[j] = \n              tempCharArray[len - 1 - j];\n        &#125;\n\n        String reversePalindrome = new String(charArray);\n        IO.println(reversePalindrome);\n    &#125;\n&#125;\n程序运行后输出如下\ndoT saw I was toD\n\n要实现字符串反转，程序需要将字符串转换为字符数组（第一个for循环），将数组反转后转换为第二个数组（第二个for循环），最后再转换回字符串。String类提供了一个方法getChars()，可将字符串或字符串片段转换为字符数组，因此我们可以将上述程序中的第一个for循环替换为：\npalindrome.getChars(0, len, tempCharArray, 0);\n\n字符串连接String 类包含一个用于连接两个字符串的方法：\nstring1.concat(string2);\n这将返回一个新字符串，该字符串是在 string1 末尾追加 string2 形成的。您也可以像这样使用字符串字面量与concat()方法：\n\"My name is \".concat(\"Rumplestiltskin\");\n字符串通常使用 + 运算符进行连接，例如：\n\"Hello,\" + \" world\" + \"!\";\n结果是:\n\"Hello, world!\";\n+ 运算符在打印语句中被广泛使用。例如：\nString string1 = \"saw I was \";\nIO.println(\"Dot \" + string1 + \"Tod\");\n打印如下:\nDot saw I was Tod\n这种连接可以包含任意对象的组合。对于每个非字符串对象，都会调用其 toString() 方法将其转换为字符串。\n\n注意：在Java SE 15之前，Java编程语言不允许字面量字符串在源文件中跨行，因此在多行字符串中必须使用+连接运算符将每行末尾连接起来。例如：\n\nString quote = \n    \"Now is the time for all good \" +\n    \"men to come to the aid of their country.\";\n在打印语句中，使用 + 连接运算符在行间断开字符串的做法非常常见。从 Java SE 15 开始，您可以编写二维字符串字面量：\nString html = \"\"\"\n              &lt;html>\n                  &lt;body>\n                      &lt;p>Hello, world&lt;/p>\n                  &lt;/body>\n              &lt;/html>\n              \"\"\";\n\n创建格式化的字符串您已经了解了使用 printf() 和 format() 方法打印格式化数字输出的用法。String 类提供了一个等效的类方法 format()，该方法返回的是 String 对象而非 PrintStream 对象。使用字符串的静态format()方法，可以创建可重复使用的格式化字符串，而非仅限于单次使用的print语句。例如，与其使用\nSystem.out.printf(\"The value of the float \" +\n                  \"variable is %f, while \" +\n                  \"the value of the \" + \n                  \"integer variable is %d, \" +\n                  \"and the string is %s\", \n                  floatVar, intVar, stringVar); \n你可以这样写：\nString fs;\nfs = String.format(\"The value of the float \" +\n                   \"variable is %f, while \" +\n                   \"the value of the \" + \n                   \"integer variable is %d, \" +\n                   \" and the string is %s\",\n                   floatVar, intVar, stringVar);\nIO.println(fs);\n\n将字符串转换为数字程序经常会将数值数据存储在字符串对象中——例如用户输入的值。包装基本数值类型的Number子类（Byte、Integer、Double、Float、Long和Short）均提供名为valueOf()的类方法，用于将字符串转换为该类型的对象。以下示例 ValueOfDemo 从命令行获取两个字符串，将其转换为数字并执行算术运算：\npublic class ValueOfDemo &#123;\n    public static void main(String[] args) &#123;\n        // this program requires two\n        // arguments on the command line\n        if (args.length == 2) &#123;\n            // convert strings to numbers\n            float a = (Float.valueOf(args[0])).floatValue();\n            float b = (Float.valueOf(args[1])).floatValue();\n\n            // do some arithmetic\n            IO.println(\"a + b = \" + (a + b));\n            IO.println(\"a - b = \" + (a - b));\n            IO.println(\"a * b = \" + (a * b));\n            IO.println(\"a / b = \" + (a / b));\n            IO.println(\"a % b = \" + (a % b));\n        &#125; else &#123;\n            IO.println(\"This program requires two command-line arguments.\");\n        &#125;\n    &#125;\n&#125;\n以下是使用命令行参数 4.5 和 87.2 时程序的输出结果：\na + b = 91.7\na - b = -82.7\na * b = 392.4\na / b = 0.051605508\na % b = 4.5\n\n注意：每个包装基本数值类型的Number子类都提供了parseXXXX()方法。例如，parseFloat()可用于将字符串转换为基本数值类型。由于该方法返回的是基本类型而非对象，因此parseFloat()比valueOf()方法更直接。例如在ValueOfDemo程序中，我们可以使用：\n\nfloat a = Float.parseFloat(args[0]);\nfloat b = Float.parseFloat(args[1]);\n\n将数字转换为字符串有时需要将数字转换为字符串，因为需要对字符串形式的值进行操作。将数字转换为字符串有多种简单方法：\nint i;\nString s1 = \"\" + i;\n或者\nString s2 = String.valueOf(i);\n每个数字子类都包含一个类方法 toString()，该方法将把其基本类型转换为字符串。例如：\nint i;\ndouble d;\nString s3 = Integer.toString(i);\nString s4 = Double.toString(d);\nToStringDemo 示例使用toString()方法将数字转换为字符串。程序随后运用若干字符串方法计算小数点前后各有多少位数：\npublic class ToStringDemo &#123;\n    public static void main(String[] args) &#123;\n        double d = 858.48;\n        String s = Double.toString(d);\n\n        int dot = s.indexOf('.');\n\n        IO.println(dot + \" digits before decimal point.\");\n        IO.println(s.length() - dot - 1 + \" digits after decimal point.\");\n    &#125;\n&#125;\n这个程序的输出如下：\n3 digits before decimal point.\n2 digits after decimal point.\n\n通过索引获取字符和子字符串String类提供了一系列方法，用于检查字符串内容、查找字符或子字符串、转换大小写以及执行其他操作。您可以通过调用 charAt() 访问器方法获取字符串中特定索引处的字符。第一个字符的索引为 0，而最后一个字符的索引为 length() - 1。例如，以下代码获取字符串中索引为 9 的字符：\nString anotherPalindrome = \"Niagara. 0 rora again!\";\nchar aChar = anotherPalindrome.charAt(9);\n索引从0开始，因此索引为9的字符是 ‘O’，如下图所示：若需从字符串中获取多个连续字符，可使用子字符串方法。该方法有两种版本：\n\nString substring(int beginIndex, int endIndex): 返回一个新字符串，该字符串是当前字符串的子字符串。子字符串从指定的 beginIndex 开始，延伸至索引为 endIndex - 1 的字符处。\nString substring(int beginIndex): 返回一个新字符串，该字符串是当前字符串的子字符串。整数参数指定起始字符的索引位置。在此处，返回的子字符串将延伸至原始字符串的末尾。\n\n以下代码从Niagara回文字符串中提取从索引11开始，延伸至索引15（不包含索引15本身）的子字符串，该子字符串即为单词”roar”：\nString anotherPalindrome = \"Niagara. O roar again!\"; \nString roar = anotherPalindrome.substring(11, 15); \n\n其他字符串操作方法以下是其他几个用于操作字符串的字符串方法：\n\nString[] split(String regex) 和 String[] split(String regex, int limit)根据字符串参数（包含正则表达式）指定的匹配条件进行搜索，并将该字符串按匹配结果拆分为字符串数组。可选的整数参数用于指定返回数组的最大大小。正则表达式的详细说明请参阅标题为”正则表达式”的章节。\nCharSequence subSequence(int beginIndex, int endIndex):  返回一个新的字符序列，该序列从 beginIndex 索引开始，直至 endIndex - 1 结束。\nString trim(): 返回此字符串的副本，其中首尾空格已被移除。\nString toLowerCase() 和  String toUpperCase():  返回此字符串转换为小写或大写的副本。若无需转换，这些方法将返回原始字符串。\n\n在字符串中搜索字符和子字符串以下是用于在字符串中查找字符或子字符串的其他 String 方法。String 类提供了访问方法，用于返回特定字符或子字符串在字符串中的位置：indexOf() 和 lastIndexOf()。indexOf() 方法从字符串开头向前搜索，lastIndexOf() 方法从字符串结尾向后搜索。如果未找到字符或子字符串，indexOf() 和 lastIndexOf() 将返回 -1。String类还提供了一个搜索方法contains，该方法用于判断字符串是否包含特定字符序列，若包含则返回true。当您仅需确认字符串是否包含某个字符序列，而精确位置无关紧要时，可使用此方法。搜索方法如下：\n\nint indexOf(int ch) 和 int lastIndexOf(int ch)：返回指定字符首次（最后一次）出现的索引。\nint indexOf(int ch, int fromIndex) 和 int lastIndexOf(int ch, int fromIndex): 返回指定字符首次（最后）出现的索引位置，从指定索引位置开始向前（向后）搜索。\nint indexOf(String str) 和 int lastIndexOf(String str)：返回指定子字符串首次（最后一次）出现的索引位置。\nint indexOf(String str, int fromIndex) 和 int lastIndexOf(String str, int fromIndex)：返回指定子字符串首次（最后一次）出现的索引位置，从指定索引开始向前（向后）搜索。\n布尔值 contains(字符序列 s)：若字符串包含指定字符序列，则返回 true。\n注：CharSequence 是由 String 类实现的一个接口。因此，你可以将字符串作为 contains() 方法的参数使用。\n\n\n\n将字符和子字符串替换到字符串中String类中用于向字符串插入字符或子字符串的方法非常有限。通常这些方法并不必要：你可以通过将从字符串中移除的子字符串与要插入的子字符串进行连接，来创建一个新的字符串。String类确实提供了四个用于替换已找到字符或子字符串的方法，它们分别是：\n\nString replace(char oldChar, char newChar): 返回一个新字符串，该字符串中所有 oldChar 的出现位置均被替换为newChar。\nString replace(CharSequence target, CharSequence replacement): 将该字符串中与目标字符串完全匹配的每个子字符串替换为指定的替换字符串。\nString replaceAll(String regex, String replacement): 将此字符串中匹配给定正则表达式的每个子字符串替换为给定的替换内容。\nString replaceFirst(String regex, String replacement): 将此字符串中第一个匹配给定正则表达式的子字符串替换为给定的替换内容。\n\n正则表达式在名为 正则表达式 的课程中进行讲解。\nString 类实战以下类 Filename 演示了如何使用 lastIndexOf() 和 substring() 方法来提取文件名的不同部分。\n\n注意：以下 Filename 类中的方法不进行任何错误检查，假定其参数包含完整的目录路径和带扩展名的文件名。若这些方法用于生产环境代码，则需验证参数是否构造正确。\n\npublic class Filename &#123;\n    private String fullPath;\n    private char pathSeparator, \n                 extensionSeparator;\n\n    public Filename(String str, char sep, char ext) &#123;\n        fullPath = str;\n        pathSeparator = sep;\n        extensionSeparator = ext;\n    &#125;\n\n    public String extension() &#123;\n        int dot = fullPath.lastIndexOf(extensionSeparator);\n        return fullPath.substring(dot + 1);\n    &#125;\n\n    // gets filename without extension\n    public String filename() &#123;\n        int dot = fullPath.lastIndexOf(extensionSeparator);\n        int sep = fullPath.lastIndexOf(pathSeparator);\n        return fullPath.substring(sep + 1, dot);\n    &#125;\n\n    public String path() &#123;\n        int sep = fullPath.lastIndexOf(pathSeparator);\n        return fullPath.substring(0, sep);\n    &#125;\n&#125;\n\n以下是一个名为 FileNameDemo 的程序，它构造了一个 FileName 对象并调用其所有方法：\npublic class FilenameDemo &#123;\n    public static void main(String[] args) &#123;\n        final String FPATH = \"/home/user/index.html\";\n        Filename myHomePage = new Filename(FPATH, '/', '.');\n        IO.println(\"Extension = \" + myHomePage.extension());\n        IO.println(\"Filename = \" + myHomePage.filename());\n        IO.println(\"Path = \" + myHomePage.path());\n    &#125;\n&#125;\n程序输出如下\nExtension = html\nFilename = index\nPath = /home/user\n如下图所示，我们的扩展方法使用 lastIndexOf() 定位文件名中最后一个句点 (.) 的位置。随后通过 substring 方法利用lastIndexOf()的返回值提取文件名扩展名——即从句点到字符串末尾的子字符串。此代码假设文件名中包含句点；若文件名不含句点，lastIndexOf()将返回-1，substring方法将抛出StringIndexOutOfBoundsException异常。\n此外，请注意扩展方法将 dot + 1 作为substring()的参数。若句点字符(.)是字符串的最后一个字符，则 dot + 1 等于字符串的长度，这比字符串的最大索引大1（因为索引从0开始）。这是 substring() 方法的合法参数，因为该方法接受等于字符串长度但不大于该长度的索引值，并将其解释为”字符串末尾”。\n比较字符串与字符串片段String 类提供了一系列用于比较字符串及字符串片段的方法。下表列出了这些方法。\n\nboolean endsWith(String suffix) 和 boolean startsWith(String prefix): 如果该字符串以方法参数指定的子字符串结尾或开头，则返回 true。\nboolean startsWith(String prefix, int offset): 从索引偏移量开始检查字符串，若其开头与作为参数指定的子字符串匹配，则返回 true。\nint compareTo(String anotherString): 比较两个字符串的字典顺序。返回一个整数，表示该字符串是否大于（结果大于0）、等于（结果等于0）或小于（结果小于0）参数。\nint compareToIgnoreCase(String str): 比较两个字符串的字典顺序，忽略大小写差异。返回一个整数，表示该字符串是否大于（结果大于0）、等于（结果等于0）或小于（结果小于0）参数。\nboolean equals(Object anObject): 仅当参数是一个字符串对象，且该对象表示的字符序列与本对象相同，才返回 true。\nboolean equalsIgnoreCase(String anotherString): 当且仅当参数是一个字符串对象，且该对象表示的字符序列与本对象相同（忽略大小写差异）时返回 true。\nboolean regionMatches(int toffset, String other, int ooffset, int len): 测试此字符串的指定区域是否与字符串参数的指定区域匹配。区域长度为 len，起始位置为本字符串的索引 toffset 和另一字符串的索引 offset。\nboolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len): 测试此字符串的指定区域是否与String参数的指定区域匹配。区域长度为 len，起始位置为本字符串的索引 toffset 和另一字符串的索引 ooffset。布尔参数用于指示是否忽略大小写；若为 true，则比较字符时忽略大小写。\nboolean matches(String regex):  测试该字符串是否匹配指定的正则表达式。正则表达式相关内容详见正则表达式课程。\n\n以下程序 RegionMatchesDemo 使用 regionMatches() 方法在另一个字符串中搜索字符串：\npublic class RegionMatchesDemo &#123;\n    public static void main(String[] args) &#123;\n        String searchMe = \"Green Eggs and Ham\";\n        String findMe = \"Eggs\";\n\n        int searchMeLength = searchMe.length();\n        int findMeLength = findMe.length();\n\n        boolean foundIt = false;\n        \n        for (int i = 0; i &lt;= (searchMeLength - findMeLength); i++) &#123;\n            if (searchMe.regionMatches(i, findMe, 0, findMeLength)) &#123;\n                foundIt = true;\n                IO.println(searchMe.substring(i, i + findMeLength));\n                break;\n            &#125;   \n        &#125;\n\n        if(!foundIt) &#123;\n            IO.println(\"No match found\");\n        &#125;\n    &#125;\n&#125;\n程序输出 Eggs。\n该程序逐个字符遍历 searchMe() 所指向的字符串。对于每个字符，程序调用regionMatches()方法来判断以当前字符开头的子字符串是否与程序正在查找的字符串匹配。\n","categories":["技术","Java"],"tags":["Java Programming Language"]},{"title":"变量与命名","url":"//technology/java/variables/","content":"变量如前一篇提到的，一个对象使用 fields 存储它自己的 states 。\nint cadence = 0;\nint speed = 0;\nint gear = 1;\n\nJava 编程语言定义以下几种变量：\n\n\nInstance Variables(Non-Static Fields) 严格来说，对象使用”non-static fields”存储它们个体的状态。也就是说，字段在声明的时候不包含 static 关键字。非静态字段也被认为是实例字段是因为它们的值在每个类的实例中都是唯一的。一辆自行车的当前速度独立于另一辆自行车的当前速度。  \nClass Variables(Static Fields) 类变量是任何用 static修饰符修饰的字段。这个修饰符告诉编译器，该变量仅存在一份副本,不用理会该类被实例化了多少次。定义特定类型自行车齿轮数量的字段可标记为静态，因为概念上所有实例都将采用相同的齿轮数量。以下代码将会创建一个这样的静态字段。额外地，final 关键字将会被添加用来表明这个齿轮的数量永远不会改变。\n\nstatic final int numGears = 6;\n\nLocal Variables  类似于对象如何用字段存储它们的状态，一个方法将会经常存储它的临时状态到 local variables 中。声明局部变量的语法和声明字段类似，没有什么特殊的关键字指定一个变量是一个局部变量。该变量的作用域完全取决于变量声明的位置，那就是一个方法的开闭大括号之间。因此，局部变量仅仅在声明的方法内可见，类的剩余部分无法访问它。\nParameters 已经在前面见过了。main(String[] args) 这个args就是参数。特别重要的是，请记住参数被归类为 variables 而不是 fields。这一规则同样也适用于其他接受参数的概念。（such as constructors and exception hanlers）\n\n\n话虽如此，讨论 variables 和 fields 时，通常遵循以下准则。当我们谈论的是一般意义上的 fields 时，我们简单的称它们为 fields。如果讨论适用于以上所有变量类型时，我们称它们为 variables。若语境需要区分变量类型时，我们将酌情更特殊的术语（例如static field,local variables,etc.）。你可能也会偶尔看到属于 member。一个类型的字段，方法，和嵌套类型都被称为该类型的成员。 \n命名每个编程语言都有自己的一套规则和约定，规定了什么是允许的名称类型，Java也没有什么不同。这些规则和约定可以总结如下：  \n\n\n变量名称是大小写敏感的。一个变量的名称可以是任何合法的Identifier。一个不限制长度的Unicode字符序列和数字的组合，开头是字母，美元符号\\$，或下划线_。然而，惯例总是用字母开头而不是\\$或_。额外地，\\$已经不再使用。你可能会发现，在一些自动生成的变量名中仍然使用了$符号，但是你的变量明应该始终避免使用它。一个相似的惯例是下划线_，虽然从技术书上讲变量名以下划线_开头是合法的，这种实践不被推荐。不允许出现空白区域。\n随后的字符可以是字母，数字，美元符号\\$，或下划线_的任意组合。当你给变量命名时，使用全部词语替代隐晦的缩写。这么做将会使你的代码容易阅读和理解。在很多例子中，它也会使你的代码自文档化。举例来说，用speed,gear,cadence比隐晦的名称更易懂，例如s,c和g。同时也要注意，不能取关键字和保留字作为变量名。\n如果你选择的名字仅由一个单词组成，那么该单词的所有字母都应该是小写。如果它由多个单词组成，大写第二个及后续单词的首字母。gearRatio和currentGear的都是很典型的例子。对于静态变量NUM_GEARS &#x3D; 6，惯例有些许不同。所有字母都大写并且是用下划线_分隔单词。按照惯例，下划线_不会在其他地方使用了\n\n\n","categories":["技术","Java"],"tags":["Java Programming Language"]},{"title":"何时使用嵌套类，局部类，匿名类和Lambda表达式","url":"//technology/java/when-to-use/","content":"在嵌套类、局部类、匿名类和Lambda表达式之间进行选择如嵌套类章节所述，嵌套类可将仅在单一位置使用的类进行逻辑分组，增强封装性，并创建更易读易维护的代码。局部类、匿名类和lambda表达式同样具备这些优势，但它们适用于更特定的场景：嵌套类、局部类、匿名类与lambda表达式的选择：\n\n\n局部类：当需要创建多个类实例、访问构造函数或引入新的命名类型时使用（例如后续需要调用额外方法）。嵌套类、局部类、匿名类与Lambda表达式的选择\n匿名类：当需要声明字段或额外方法时使用。\nLambda表达式:\n当你需要封装单一行为单元并将其传递给其他代码时，请使用它。例如，当你希望对集合中的每个元素执行特定操作、在进程完成时触发操作，或在进程遇到错误时执行操作时，就可以使用lambda表达式。\n当您需要一个功能接口的简单实例且不满足上述任何条件时（例如，您不需要构造函数、命名类型、字段或额外方法），请使用此方案。\n\n\n嵌套类：当你的需求类似于局部类，希望使该类型更广泛可用，且不需要访问局部变量或方法参数时使用。\n若需访问外部类的非公开字段和方法，请使用非静态嵌套类（或内部类）；若无需此类访问权限，则使用静态嵌套类。\n\n","categories":["技术","Java"],"tags":["Java Programming Language"]},{"title":"Switch 语句","url":"//technology/java/switch-statements/","content":"使用Switch语句控制程序流程switch 语句是Java语言中五种控制流语句之一，它允许存在任意数量的执行路径。switch语句以选择器变量作为参数，并根据该变量的值来选择将要执行的路径。\n您必须从以下类型中选择选择器变量的类型：\n\nbyte, short, char, int 基础类型\nCharacter, Byte, Short, Integer 包装类型\n枚举类型\n字符串类型\n\n值得注意的是，以下基本类型不能用于选择器变量的类型：boolean、long、float 和 double。\n\n让我们看一个使用switch语句的简单示例：\nint quarter = 1; // any value\n    String quarterLabel = null ;\n    switch (quarter) &#123;\n        case 0: quarterLabel = \"Q1 - Winter\";`\n            break;\n        case 1: quarterLabel = \"Q2 - Spring\";\n            break;\n        case 2: quarterLabel = \"Q3 - Summer\";\n            break;\n        case 3: quarterLabel = \"Q4 - Fall\";\n            break;\n        default: quarterLabel = \"Unknown quarter\";        \n    &#125;\nswitch 语句的主体称为 switch 代码块。switch 代码块中的语句可标记为一个或多个 case 标签或 default 标签。switch 语句会先评估其表达式，然后执行所有位于匹配 case 标签之后的语句。\n您可能已经注意到 break 关键字的使用。每个 break 语句都会终止其所在的 switch 语句块。控制流将从 switch 块后的第一个语句继续执行。break 语句是必要的，因为若没有它们，switch 块中的语句会发生穿透执行。匹配的 case 标签之后的所有语句都会依次执行，无论后续case 标签的表达式如何，直到遇到 break 语句为止。\n以下代码使用穿透机制填充 futureMonths 列表。\npublic static void main(String[] args) &#123;\n    int month = 8;\n    List&lt;String> futureMonths = new ArrayList&lt;>();\n    switch (month) &#123;\n        case 1: futureMonths.add(\"January\");\n        case 2: futureMonths.add(\"February\");\n        case 3: futureMonths.add(\"March\");\n        case 4: futureMonths.add(\"April\");\n        case 5: futureMonths.add(\"May\");\n        case 6: futureMonths.add(\"June\");\n        case 7: futureMonths.add(\"July\");\n        case 8: futureMonths.add(\"August\");\n        case 9: futureMonths.add(\"September\");\n        case 10: futureMonths.add(\"October\");\n        case 11: futureMonths.add(\"November\");\n        case 12: futureMonths.add(\"December\");\n            break;\n        default:\n            break;\n    &#125;\n    IO.println(futureMonths);\n&#125;\n程序将输出以下内容：\n[August, September, October, November, December]\n\n严格来说，最后的 break 语句并非必需，因为流程会自然跳出 switch 语句。但建议使用 break 语句，这样修改代码时更容易且不易出错。\ndefault 部分处理所有未被任何 case 部分明确处理的值。以下代码示例展示了单个语句如何包含多个 case 标签。该示例计算特定月份的天数：\npublic int calculateDaysInMonth(int year, int month)&#123;\n    int days = 0;\n    switch(month)&#123;\n        case 1, 3, 5, 7, 8, 10, 12 -> days = 31;\n        case 4, 6, 9, 11 -> days = 30;\n        case 2 ->  &#123;\n            if(((year % 4 == 0) &amp;&amp; (year % 100 != 0)) || (year % 400 == 0))&#123;\n                days = 29;\n            &#125; else &#123;\n                days = 28;\n            &#125;\n        &#125;\n        default -> IO.println(\"Invalid month: \" + month);\n    &#125;\n    return days;\n&#125;\n这段代码中一个语句对应多个情况。\n在 Switch 语句和 If-then-else 语句之间进行选择决定使用 if-then-else 语句还是 switch 语句，取决于代码的可读性以及语句所测试的表达式类型。if-then-else 语句可基于值的范围或条件来测试表达式，而 switch 语句仅能基于单个整数、枚举值或字符串对象来测试表达式。例如，以下代码可以用 switch 语句来实现。\nint month = ...; // any month\nif (month ==1) &#123;\n    IO.println(\"January\");\n&#125; else if (month == 2)&#123;\n    IO.println(\"February\");\n&#125; ... // and so on\n另一方面，以下内容无法使用 switch 语句编写，因为 switch 语句不支持布尔类型的标签。\nint remperature = ...; // any temperature\nif (temperature &lt; 0) &#123;\n    IO.println(\"Water is ice\");\n&#125; else if (temperature &lt; 100)&#123;\n    IO.println(\"Water is liquid, known as water\");\n&#125; else &#123;\n    IO.println(\"Water is vapor\");\n&#125;\n\n使用 String 作为 Case 标签在 Java SE 7 及更高版本中，您可以在 switch 语句的表达式中使用 String 对象。以下代码示例根据名为 month 的 String 值显示月份编号。\nString month = \"March\"; // any month\nint monthNumber = -1;\nswitch (month.toLowerCase()) &#123;\n    case \"january\": monthNumber = 1;\n        break;\n    case \"february\": monthNumber = 2;\n        break;\n    case \"march\": monthNumber = 3;\n        break;\n    case \"april\": monthNumber = 4;\n        break;\n    case \"may\": monthNumber = 5;\n        break;\n    case \"june\": monthNumber = 6;\n        break;\n    case \"july\": monthNumber = 7;\n        break;\n    case \"august\": monthNumber = 8;\n        break;\n    case \"september\": monthNumber = 9;\n        break;\n    case \"october\": monthNumber = 10;\n        break;\n    case \"november\": monthNumber = 11;\n        break;\n    case \"december\": monthNumber = 12;\n        break;\n    default: monthNumber = 0;\n        break;\n&#125;\n在 switch 表达式中，字符串与每个 case 标签关联的表达式进行比较，如同使用 String.equals() 方法一样。为了使本示例能够接受任何月份（不区分大小写），month 被转换为小写（使用 toLowerCase() 方法），且所有与 case 标签关联的字符串均为小写。\nNull 值处理switch 语句的选项变量可以是对象，因此该对象可能为空。你应保护代码免受空选项变量的影响，因为此时switch语句将抛出 NullPointerException 异常。\n","categories":["技术","Java"],"tags":["Java Programming Language"]}]